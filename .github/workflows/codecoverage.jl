#===============================================================================
 Parse an LCOV file generated by julia-actions/processcoverage
 and generate a simple code coverage report for CI logs.
 
 Usage: julia codecoverage.jl path/to/lcov.info dir1/,dir2/,...

 First argument:  LCOV file
 Second argument: Comma-separated (no whitespace!) list of directories 
                  to be included in the summary. If none provided, include all.

 Note: If the LCOV file was generated from a different directory than
       than the current working directory, then relative paths in it might
       not match any of the directories given in the filter list.       
================================================================================#

using Printf

# ANSI escape sequences for console text styles/colours
ANSI_BOLD   = "\e[1m"  # bold
ANSI_RESET  = "\e[0m"  # reset output text style
ANSI_RED    = "\e[31m"
ANSI_GREEN  = "\e[32m"
ANSI_YELLOW = "\e[33m"
ANSI_CYAN   = "\e[36m"

# get string representation for single coverage data point
function coverage2str(ncovered::Int, ntotal::Int)
    percentage = ntotal == 0 ? 100 : 100 * ncovered / ntotal
    colourmap(x) = x >= 90 ? ANSI_GREEN : (x >= 60 ? ANSI_YELLOW : ANSI_RED)

    ANSI_BOLD * colourmap(percentage) * @sprintf("%3d%%", percentage) * ANSI_RESET
end

function print_coverage_summary(fname::AbstractString; show_uncovered_lines=true, 
    directories::AbstractVector{<:AbstractString}=AbstractString[]
)
    # ---- some book-keeping ----
    ncovered = 0
    ncovered_total = 0
    nlines_total = 0

    # indicates whether any previous line of the current file has been executed
    # (used to generate proper output)
    has_uncovered_line = false

    # indicates whether the file that the current line belongs to is included in the summary or not
    include_current_line = true

    # indicates whether both the current line and its predecessor at line number -1
    # are uncovered (so that they could be merged into a line number range in the output)
    isrange = false
    # store the most recent uncovered line number
    prev_uncovered_line = -1

    # ---- print summary (single pass through lcov file) ----

    println(ANSI_BOLD, "Code Coverage Summary:", ANSI_RESET)

    for line in eachline(ARGS[1])
        if startswith(line, "end_of_record")  # end of current file
            include_current_line = true  # reset
        else
            include_current_line || continue
            prefix, data = line[1:2], line[4:end]
            
            if prefix == "SF"  # start of new file
                # if a directory filter is specified, the directory containing the current file
                # must be a subdirectory of one the specified filters
                include_current_line = isempty(directories) || 
                    any(contains(abspath(dirname(data)), abspath(dir)) for dir in directories)
                
                if include_current_line
                    println(data)

                    # reset
                    isrange = false
                    prev_uncovered_line = -1
                end

            elseif prefix == "DA" && show_uncovered_lines  # coverage count for a single code line
                ln, lc = parse.(Int, split(data, ","))  # (assuming a well-formed lcov file)

                if lc == 0  # line was never executed
                    if !isrange
                        if ln == prev_uncovered_line + 1
                            # start new range from previous line number
                            # and do not print current line number (yet)
                            isrange = true
                        else
                            # print current line number
                            if has_uncovered_line
                                print(", ", ln)
                            else
                                has_uncovered_line = true
                                print("   Uncovered lines:  ", ANSI_CYAN, ln)
                            end
                        end
                    elseif ln > prev_uncovered_line + 1  # current range cannot be extended to current line
                        # print end of range and open new range
                        print("-", prev_uncovered_line, ", ", ln)
                        isrange = false
                    end

                    prev_uncovered_line = ln
                else
                    if isrange
                        # print end of range
                        print("-", prev_uncovered_line)

                        # lines are listed consecutively, 
                        # so a covered line closes any open range of uncovered lines
                        isrange = false
                    end
                end

            elseif prefix == "LH"  # end of individual line coverage data
                if has_uncovered_line
                    has_uncovered_line = false
                    println()
                end
                print(ANSI_RESET)  # reset colour

                # store number of covered lines in current file
                ncovered = parse(Int, data)

            elseif prefix == "LF"  # total line count of current file
                nlines = parse(Int, data)
                ncovered_total += ncovered
                nlines_total   += nlines

                print("   Coverage: ", coverage2str(ncovered, nlines))
                println(" (", ncovered, "/", nlines, " lines)")
            end
        end
    end

    # TODO still printed if no directory matches the filter
    print(ANSI_BOLD, "Total coverage: ", ANSI_RESET, coverage2str(ncovered_total, nlines_total))
    println(" (", ncovered_total, "/", nlines_total, " lines)")
end


# process command-line arguments and run summary function

length(ARGS) > 0 || error("no path specified")
isfile(ARGS[1]) || error("file not found: ", ARGS[1])

dirs = AbstractString[]
if length(ARGS) > 1
    dirs = split(ARGS[2], ",")
    all(isdir, dirs) || error("directory not found")
    # TODO ignore invalid directories
end

print_coverage_summary(ARGS[1]; show_uncovered_lines=true, directories=dirs)