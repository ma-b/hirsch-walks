# Parse coverage file lcov.info generated by julia-actions/processcoverage
# and generate a simple code coverage report for CI logs

using Printf

# ANSI escape sequences for console text styles/colours
ANSI_BOLD   = "\e[1m"  # bold
ANSI_RESET  = "\e[0m"  # reset output text style
ANSI_RED    = "\e[31m"
ANSI_GREEN  = "\e[32m"
ANSI_YELLOW = "\e[33m"
ANSI_CYAN   = "\e[36m"

# get string representation for single coverage data point
function coverage_str(ncovered::Int, ntotal::Int)
    percentage = ntotal == 0 ? 100 : 100 * ncovered / ntotal
    colourmap(x) = x >= 90 ? ANSI_GREEN : (x >= 60 ? ANSI_YELLOW : ANSI_RED)

    ANSI_BOLD * colourmap(percentage) * @sprintf("%3d%%", percentage) * ANSI_RESET
end

function print_coverage_report(fname::AbstractString; show_uncovered_lines=true)
    # ---- some book-keeping ----
    ncovered = 0
    ncovered_total = 0
    nlines_total = 0

    # indicates whether some previous line of the current file was not executed
    # (used to generate proper output)
    has_uncovered_line = false

    # line number ranges
    prev_uncov_line = -1
    isopen_range = false  # true if ...

    # ---- print summary (single pass through lcov file) ----

    println(ANSI_BOLD, "Code Coverage Summary:", ANSI_RESET)

    for line in eachline(ARGS[1])
        prefix, data = line[1:2], line[4:end]
        
        if prefix == "SF"  # start of new file
            println(data)
            
            # reset
            prev_uncov_line = -1
            isopen_range = false

        elseif prefix == "DA" && show_uncovered_lines  # coverage count for a single code line
            ln, lc = parse.(Int, split(data, ","))  # (assuming a well-formed lcov file)

            if lc == 0  # line was never executed
                if !isopen_range
                    if ln == prev_uncov_line + 1
                        # start new range from previous line number
                        # and do not print current line number (yet)
                        isopen_range = true
                    else
                        # print current line number
                        if has_uncovered_line
                            print(", ", ln)
                        else
                            has_uncovered_line = true
                            print("   Uncovered lines:  ", ANSI_CYAN, ln)
                        end
                    end
                elseif ln > prev_uncov_line + 1  # current range cannot be extended to current line
                    # print end of range and open new range
                    print("-", prev_uncov_line, ", ", ln)

                    isopen_range = false
                end

                prev_uncov_line = ln
            else
                if isopen_range
                    # print end of range
                    print("-", prev_uncov_line)

                    # lines are listed consecutively, so a covered line closes any open range of uncovered lines
                    isopen_range = false
                end
            end

        elseif prefix == "LH"  # end of individual line coverage data
            if has_uncovered_line
                has_uncovered_line = false
                println()
            end
            print(ANSI_RESET)  # reset colour

            # store number of covered lines in current file
            ncovered = parse(Int, data)

        elseif prefix == "LF"  # total line count of current file
            nlines = parse(Int, data)
            ncovered_total += ncovered
            nlines_total   += nlines

            print("   Coverage: ", coverage_str(ncovered, nlines))
            println(" (", ncovered, "/", nlines, " lines)")
        end
    end

    print(ANSI_BOLD, "Total coverage: ", ANSI_RESET, coverage_str(ncovered_total, nlines_total))
    println(" (", ncovered_total, "/", nlines_total, " lines)")
end

length(ARGS) > 0 || error("no path specified")
isfile(ARGS[1]) || error("file not found: ", ARGS[1])
print_coverage_report(ARGS[1]; show_uncovered_lines=true)