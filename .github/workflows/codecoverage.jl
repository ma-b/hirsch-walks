# Parse coverage file lcov.info generated by julia-actions/processcoverage
# and generate a simple code coverage report for CI logs

using Printf

# get string representation for single data point
function coverage_str(ncovered::Int, ntotal::Int)
    percentage = ntotal == 0 ? 100 : 100 * ncovered / ntotal
    colourmap(x) = x >= 90 ? 2 : (x >= 60 ? 3 : 1)  # red 1, yellow 3, green 2

    "\e[3" * string(colourmap(percentage)) * "m\033[1m" * # bold
        @sprintf("%3d%%", percentage) * 
        "\033[0m"  # reset output text style
end

# (single pass through file)
function print_coverage_report(fname::AbstractString; show_uncovered_lines=true)
    ncovered = 0
    ncovered_total = 0
    nlines_total = 0

    # indicates whether some previous line of the current file was not executed
    # (used to generate proper output)
    has_uncovered_line = false

    # book-keeping for line number ranges
    prev_uncov_line = -1
    isopen_range = false

    println("\033[1mCode Coverage Summary:\033[0m")

    for line in eachline(ARGS[1])
        prefix, data = line[1:2], line[4:end]
        
        if prefix == "SF"  # start of new file
            println(data)
            
            prev_uncov_line = -1
            isopen_range = false

        elseif prefix == "DA" && show_uncovered_lines  # coverage count for a single code line
            ln, lc = parse.(Int, split(data, ","))  # (assuming a well-formed lcov file)

            if lc == 0  # line was never executed
                #println((ln, prev_uncov_line, isopen_range))

                if !isopen_range
                    if ln == prev_uncov_line + 1
                        # start new range from previous line number
                        # and do not print current line number (yet)
                        isopen_range = true
                    else
                        # print
                        if has_uncovered_line
                            print(", ", ln)
                        else
                            has_uncovered_line = true
                            print("   Uncovered lines:  ", "\e[36m", ln)  # cyan
                        end
                    end
                elseif ln > prev_uncov_line + 1  # current range cannot be extended to current line
                    # print end of range and open new range
                    print("-", prev_uncov_line, ", ", ln)

                    isopen_range = false
                end

                prev_uncov_line = ln
            else
                if isopen_range
                    # print end of range
                    print("-", prev_uncov_line)

                    # lines are listed consecutively, so a covered line closes any open range of uncovered lines
                    isopen_range = false
                end
            end

        elseif prefix == "LH"  # end of individual line coverage data
            if has_uncovered_line
                has_uncovered_line = false
                println()
            end
            print("\033[0m")  # reset colour

            # store number of covered lines in current file
            ncovered = parse(Int, data)
        elseif prefix == "LF"
            # total line count of current file
            nlines = parse(Int, data)
            ncovered_total += ncovered
            nlines_total   += nlines

            print("   Coverage: ", coverage_str(ncovered, nlines))
            println(" (", ncovered, "/", nlines, " lines)")
        end
    end

    print("\033[1mTotal coverage:\033[0m ", coverage_str(ncovered_total, nlines_total))
    println(" (", ncovered_total, "/", nlines_total, " lines)")
end

length(ARGS) > 0 || error("no path specified")
isfile(ARGS[1]) || error("file not found: ", ARGS[1])
print_coverage_report(ARGS[1]; show_uncovered_lines=true)