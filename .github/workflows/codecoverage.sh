#!/bin/bash
#=================================================================
# Parse an LCOV file generated by julia-actions/processcoverage
# and generate a simple code coverage report.
#=================================================================

usage()
{
    echo "Usage: codecoverage [OPTIONS]... FILE"
    echo "Print a simple summary of the code line coverage data in FILE (in LCOV format)."
    echo
    echo "Options:"
    echo "  -h             Display this help."
    echo "  -v             Verbose, print list of uncovered lines for each code file."
    echo "  -d DIR(,DIR)*  Skip data for code files that are NOT in a subdirectory of any"
    echo "                 of the given directories DIR (comma-separated list)."
    echo "                 Note: If FILE was generated in a working directory different from"
    echo "                       the current working directory, then relative paths in it might"
    echo "                       not match any of the directories given in the filter list."
}

while getopts ":hd:v" option; do  # leading : (as in ":hd:v") skips errors (handled by user)
    case "${option}" in
        v)  # verbose
            verbose=1;;
        d)  # directory filter
            # check and store: split and convert to array
            directories=(${OPTARG//,/ })  # array
            for directory in "${directories[@]}"; do
                echo $directory
                if [[ ! -d $directory ]]; then
                    echo "Invalid directory: ${directory}"
                    exit 2
                fi
            done
            ;; #shift;;
        h)  # display usage
            usage
            exit 0;;
        \?) # unrecognized option
            usage
            exit 1;;
    esac
done
# remove all options from argument list to make $1 the first positional argument
shift $((OPTIND-1))

if [[ $# -ne 1 ]]; then
    usage
    exit 2
fi

if [[ ! -f $1 ]]; then
    echo "File not found: $1"
    exit 2
fi


# ANSI escape sequences for console text styles/colours
bold="\e[1m"  # bold
normal="\e[0m"  # reset output text style

# takes 2 arguments: $1 number of covered lines, $2 total line count
function print_percentage()
{
    # TODO check number of args
    
    # calculate percentage
    if [[ $2 -eq 0 ]]; then
        percent=100
    else
        percent=$((100 * $1 / $2))  # result will be an integer (truncated)
    fi    
    
    # map percentage to one of 3 text colours
    if [[ $percent -ge 90 ]]; then
        colour=32  # green
    elif [[ $percent -ge 60 ]]; then
        colour=33  # yellow
    else
        colour=31  # red
    fi
    
    printf "$bold\e[${colour}m%3d%%$normal" $percent
}


# ---- some book-keeping ----
ncovered=0
ncovered_total=0
nlines_total=0

# Boolean flags (interpretation: 1=true, 0=false):

# indicates whether any previous line of the current file has been executed
# (used to generate proper output)
has_uncovered_line=0

# indicates whether the file that the current line belongs to 
# is included in the summary or not
include_current_line=1

# indicates whether both the current line and its predecessor at line number -1
# are uncovered (so that they could be merged into a line number range in the output)
isrange=0
# most recent uncovered line number
prev_uncovered_line=-1

# ---- print summary (single pass through file) ----

echo -e $bold"Code Coverage Summary:"$normal

while read -r line; do
    if [[ $line == "end_of_record"* ]]; then  # end of current file
        include_current_line=1  # reset to true
    else
        [[ $include_current_line -eq 1 ]] || continue
        
        # lines holding data start with a two-letter prefix, followed by a colon
        prefix=${line:0:2}
        data=${line:3:${#line}-3}
        data=${data//[$'\r\n']}  # remove carriage return and line break
        
        # start of new file
        if [[ $prefix == "SF" ]]; then
            if [[ ${#directories[@]} -eq 0 ]]; then
                # filter option not specified or empty list provided
                include_current_line=1
            else
                # if a directory filter is set, the directory containing the current file
                # must be a subdirectory of one the specified filters
                # (we check this using substring comparisons)
                include_current_line=0
                if [[ -f $data ]]; then  # ignore filenames that are invalid (relative*/absolute) paths
                                         # (* relative to current working directory!)
                    for directory in "${directories[@]}"; do
                        echo $directory
                        if [[ $(realpath $data) == "$(realpath $directory)"* ]]; then
                            include_current_line=1; break
                        fi
                    done
                fi
            fi   
            
            if [[ $include_current_line -eq 1 ]]; then
                echo $data
                isrange=0; prev_uncovered_line=-1  # reset counters
            fi
            
        # coverage count for a single code line
        elif [[ $prefix == "DA" && $verbose -eq 1 ]]; then
            # split at commas and convert to an array (assuming a well-formed lcov file)
            arrdata=(${data//,/ })
            line_number=${arrdata[0]}
            execution_count=${arrdata[1]}

            if [[ $execution_count -eq 0 ]]; then  # line was never executed
                if [[ $isrange -eq 0 ]]; then
                    if [[ $line_number -eq $((prev_uncovered_line + 1)) ]]; then
                        # start new range from previous line number
                        # and do not print current line number (yet)
                        isrange=1
                    else
                        # print current line number
                        if [[ $has_uncovered_line -eq 1 ]]; then
                            echo -n ", $line_number"
                        else
                            has_uncovered_line=1
                            echo -ne "   Uncovered lines:  \e[36m$line_number"
                        fi
                    fi
                elif [[ $line_number -gt $((prev_uncovered_line + 1)) ]]; then  # current range cannot be extended to current line
                    # print end of range and open new range
                    echo -n "-${prev_uncovered_line}, $line_number"
                    isrange=0
                fi

                prev_uncovered_line=$line_number
            else
                if [[ $isrange -eq 1 ]]; then
                    # print end of range
                    echo -n "-${prev_uncovered_line}"

                    # lines are listed consecutively, 
                    # so a covered line closes any open range of uncovered lines
                    isrange=0
                fi
            fi
            
        # end of individual line coverage data
        elif [[ $prefix == "LH" ]]; then
            if [[ $has_uncovered_line -eq 1 ]]; then
                has_uncovered_line=0
                echo;
            fi
            echo -ne $normal  # reset colour

            # store number of covered lines in current file
            ncovered=$data

        # total line count of current file
        elif [[ $prefix == "LF" ]]; then
            nlines=$data
            ncovered_total=$((ncovered_total + ncovered))
            nlines_total=$((nlines_total + nlines))

            echo -n "   Coverage: "
            print_percentage $ncovered $nlines
            echo " (${ncovered}/${nlines} lines)"
        fi
    fi
done < $1

# TODO still printed if no directory matches the filter
echo -ne $bold"Total coverage: "$normal
print_percentage $ncovered_total $nlines_total
echo " (${ncovered_total}/${nlines_total} lines)"