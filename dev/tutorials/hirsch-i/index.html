<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Spindles and the Hirsch conjecture I · Spindles.jl</title><meta name="title" content="Spindles and the Hirsch conjecture I · Spindles.jl"/><meta property="og:title" content="Spindles and the Hirsch conjecture I · Spindles.jl"/><meta property="twitter:title" content="Spindles and the Hirsch conjecture I · Spindles.jl"/><meta name="description" content="Documentation for Spindles.jl."/><meta property="og:description" content="Documentation for Spindles.jl."/><meta property="twitter:description" content="Documentation for Spindles.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Spindles.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../firststeps/">First steps</a></li><li><a class="tocitem" href="../permutahedra/">Line segments, hypercubes, and permutahedra</a></li><li class="is-active"><a class="tocitem" href>Spindles and the Hirsch conjecture I</a><ul class="internal"><li><a class="tocitem" href="#The-Hirsch-conjecture"><span>The Hirsch conjecture</span></a></li><li><a class="tocitem" href="#Reading-a-spindle-from-a-file"><span>Reading a spindle from a file</span></a></li><li><a class="tocitem" href="#Inspecting-faces"><span>Inspecting faces</span></a></li><li><a class="tocitem" href="#A-good-2-face"><span>A good 2-face</span></a></li><li><a class="tocitem" href="#Finding-all-good-2-faces"><span>Finding all good 2-faces</span></a></li></ul></li><li><a class="tocitem" href="../hirsch-ii/">Spindles and the Hirsch conjecture II</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Polytopes API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../man/polytopes/api/">Index</a></li><li><a class="tocitem" href="../../man/polytopes/polytopes/">Polytopes</a></li><li><a class="tocitem" href="../../man/polytopes/representations/">Representations</a></li><li><a class="tocitem" href="../../man/polytopes/combinatorics/">Combinatorics</a></li><li><a class="tocitem" href="../../man/polytopes/operators/">Operators</a></li><li><a class="tocitem" href="../../man/polytopes/generators/">Generators for standard polytopes</a></li><li><a class="tocitem" href="../../man/polytopes/plots/">Plotting polytopes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Analysis API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../man/goodfaces/">Good 2-faces</a></li><li><a class="tocitem" href="../../man/io/">Reading and writing files</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Spindles and the Hirsch conjecture I</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Spindles and the Hirsch conjecture I</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ma-b/hirsch-walks" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ma-b/hirsch-walks/blob/main/Spindles/examples/hirsch-i.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Spindles-and-the-Hirsch-conjecture-I"><a class="docs-heading-anchor" href="#Spindles-and-the-Hirsch-conjecture-I">Spindles and the Hirsch conjecture I</a><a id="Spindles-and-the-Hirsch-conjecture-I-1"></a><a class="docs-heading-anchor-permalink" href="#Spindles-and-the-Hirsch-conjecture-I" title="Permalink"></a></h1><p><a href="https://nbviewer.jupyter.org/github/ma-b/hirsch-walks/blob/gh-pages/dev/tutorials/Spindles and the Hirsch conjecture I.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><p>In this tutorial, we will explore a particular spindle that is known from theory to have an interesting property: Its apices are far away from each other in the graph of the spindle. This property made it possible to disprove a long-standing conjecture in polyhedral theory, the so-called <em>Hirsch conjecture</em>. Even though the focus of this tutorial is on a thorough analysis of the special spindle, we will showcase some more advanced functionalities and customization options of <em>Spindles.jl</em> along the way. For the basic usage, please read <a href="../firststeps/#First-steps">this tutorial</a> first.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This tutorial is also available as a Jupyter notebook. Click on the badge above to view it in <a href="https://nbviewer.jupyter.org/">nbviewer</a>.</p></div></div><h2 id="The-Hirsch-conjecture"><a class="docs-heading-anchor" href="#The-Hirsch-conjecture">The Hirsch conjecture</a><a id="The-Hirsch-conjecture-1"></a><a class="docs-heading-anchor-permalink" href="#The-Hirsch-conjecture" title="Permalink"></a></h2><p>The <a href="https://en.wikipedia.org/wiki/Hirsch_conjecture">Hirsch conjecture</a> for polytopes stated that any two vertices of a <span>$d$</span>-dimensional polytope with <span>$f$</span> facets can be connected by a path of at most <span>$f-d$</span> edges. It was disproved in 2010 when Francisco Santos found a <a href="https://arxiv.org/abs/1006.2814">construction</a> that produces counterexamples from spindles with a special property: the length of a shortest path between the apices (called the <em>length</em> of the spindle) must be strictly greater than the dimension.</p><p>Santos&#39; original counterexample from 2010 is based on a 5-dimensional spindle with 48 facets, for which the shortest path between the apices is of length 6. A minimal inequality description of this spindle (see Table 1 in Santos&#39; <a href="https://arxiv.org/pdf/1006.2814">paper</a>) can be found in the file <code>s-48-5.txt</code> located in the <code>examples</code> folder beneath the package root directory <code>Spindles</code>.</p><h2 id="Reading-a-spindle-from-a-file"><a class="docs-heading-anchor" href="#Reading-a-spindle-from-a-file">Reading a spindle from a file</a><a id="Reading-a-spindle-from-a-file-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-a-spindle-from-a-file" title="Permalink"></a></h2><p>The data can be read from the file using the function <a href="../../man/io/#Spindles.readineq"><code>readineq</code></a> as follows.</p><pre><code class="language-julia hljs">using Spindles
A, b, labels = readineq(&quot;../../../examples/s-48-5.txt&quot;, Int);</code></pre><p>The function returns not only the coefficient matrix <code>A</code> and vector of right-hand sides <code>b</code> of the description <span>$Ax \le b$</span></p><pre><code class="language-julia hljs">[A b]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">48×6 Matrix{Rational{Int64}}:
  1   18    0    0    0  1
  1  -18    0    0    0  1
  1    0   18    0    0  1
  1    0  -18    0    0  1
  1    0    0   45    0  1
  1    0    0  -45    0  1
  1    0    0    0   45  1
  1    0    0    0  -45  1
  1   15   15    0    0  1
  1  -15   15    0    0  1
  ⋮                      ⋮
 -1  -30  -30    0    0  1
 -1   40    0   10    0  1
 -1   40    0  -10    0  1
 -1  -40    0   10    0  1
 -1  -40    0  -10    0  1
 -1    0   40    0   10  1
 -1    0   40    0  -10  1
 -1    0  -40    0   10  1
 -1    0  -40    0  -10  1</code></pre><p>but also a label for each inequality:</p><pre><code class="language-julia hljs">labels</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">48-element Vector{String}:
 &quot;1⁺&quot;
 &quot;1⁻&quot;
 &quot;2⁺&quot;
 &quot;2⁻&quot;
 &quot;3⁺&quot;
 &quot;3⁻&quot;
 &quot;4⁺&quot;
 &quot;4⁻&quot;
 &quot;5⁺&quot;
 &quot;5⁻&quot;
 ⋮
 &quot;20⁻&quot;
 &quot;21⁺&quot;
 &quot;21⁻&quot;
 &quot;22⁺&quot;
 &quot;22⁻&quot;
 &quot;23⁺&quot;
 &quot;23⁻&quot;
 &quot;24⁺&quot;
 &quot;24⁻&quot;</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Even though we use the same set of labels as Santos in his <a href="https://arxiv.org/pdf/1006.2814">paper</a>, the assignment to the rows of <code>A</code> is different.</p></div></div><p>The resulting spindle <code>s</code> has</p><pre><code class="language-julia hljs">s = Polytope(A, b)
nvertices(s)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">322</code></pre><p>vertices and its apices are</p><pre><code class="language-julia hljs">apx = apices(s)
collect(vertices(s))[apx]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Vector{Rational{Int64}}}:
 [-1, 0, 0, 0, 0]
 [1, 0, 0, 0, 0]</code></pre><p>The distance between them in the graph of <code>s</code> is indeed 6:</p><pre><code class="language-julia hljs">dist(s, apx...)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6</code></pre><p>Note that both apices are highly degenerate:</p><pre><code class="language-julia hljs">using Graphs: degree
degree(graph(s), apx)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Int64}:
 32
 32</code></pre><h2 id="Inspecting-faces"><a class="docs-heading-anchor" href="#Inspecting-faces">Inspecting faces</a><a id="Inspecting-faces-1"></a><a class="docs-heading-anchor-permalink" href="#Inspecting-faces" title="Permalink"></a></h2><p>The original motivation for developing <em>Spindles.jl</em> was the search for special two-dimensional faces (or <em>2-faces</em> for short) of the spindle <code>s</code> and similar spindles. To explain what we mean by &quot;special&quot;, let us consider the following three facets (note that all inequalities in the description given in <code>s-48-5.txt</code> are indeed facet-defining):</p><pre><code class="language-julia hljs">face = [29, 37, 41]
labels[face]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{String}:
 &quot;15⁺&quot;
 &quot;19⁺&quot;
 &quot;21⁺&quot;</code></pre><p>They indeed define a 2-face of <code>s</code>:</p><pre><code class="language-julia hljs">dim(s, face) == 2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>To inspect <code>face</code>, we may use the <code>plot</code> command from <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a> to make a plot.</p><pre><code class="language-julia hljs">using Plots
plot(s, face; ineqlabels=labels)</code></pre><img src="8ff9fe21.svg" alt="Example block output"/><p>This creates a two-dimensional projection of <code>face</code> onto the two coordinates by which the axes are labeled above.</p><p>Each vertex is labeled by its index. Edges and the face itself get their labels from the incident facets, since we passed the <code>labels</code> extracted above to the keyword argument <code>ineqlabels</code>. Note here that the three facets that contain <code>face</code> are omitted from the edge labels.</p><p>We may customize the above plot even further. For example, let&#39;s add more information to the vertex labels. To print the distances of each vertex to the two apices of <code>s</code> on a second line beneath the vertex index, we first generate all labels in the desired format. Here, we use the format <code>&quot;dist1 | dist2&quot;</code> for the second line of the label, where <code>dist1</code> and <code>dist2</code> are placeholders for the distances to <code>apx[1]</code> and <code>apx[2]</code>, respectively.</p><pre><code class="language-julia hljs">dist_labels = map(1:nvertices(s)) do v
    &quot;$v\n&quot; * join(dist.(s, apx, v), &quot; | &quot;)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">322-element Vector{String}:
 &quot;1\n0 | 6&quot;
 &quot;2\n1 | 5&quot;
 &quot;3\n1 | 5&quot;
 &quot;4\n1 | 5&quot;
 &quot;5\n1 | 5&quot;
 &quot;6\n1 | 5&quot;
 &quot;7\n1 | 5&quot;
 &quot;8\n1 | 5&quot;
 &quot;9\n1 | 5&quot;
 &quot;10\n1 | 5&quot;
 ⋮
 &quot;314\n5 | 1&quot;
 &quot;315\n5 | 1&quot;
 &quot;316\n5 | 1&quot;
 &quot;317\n5 | 1&quot;
 &quot;318\n5 | 1&quot;
 &quot;319\n5 | 1&quot;
 &quot;320\n5 | 1&quot;
 &quot;321\n5 | 1&quot;
 &quot;322\n5 | 1&quot;</code></pre><div class="admonition is-info"><header class="admonition-header">Julia syntax</header><div class="admonition-body"><pre><code class="language-julia hljs">dist.(s, apx, v)</code></pre><p>is a shorthand for</p><pre><code class="language-julia hljs">[dist(s, a, v) for a in apx]</code></pre></div></div><p>Our custom vertex labels can now be passed to <code>plot</code> as follows:</p><pre><code class="language-julia hljs">plot(s, face; ineqlabels=labels, vertexlabels=dist_labels, usecoordinates=false)</code></pre><img src="99b5e5be.svg" alt="Example block output"/><p>Note here that the (optional) additional argument <code>usecoordinates=false</code> changed the plot mode to a (combinatorial) drawing of the graph of the face <code>15⁺ 19⁺ 21⁺</code> rather than a planar projection of its true coordinates as above.</p><h2 id="A-good-2-face"><a class="docs-heading-anchor" href="#A-good-2-face">A good 2-face</a><a id="A-good-2-face-1"></a><a class="docs-heading-anchor-permalink" href="#A-good-2-face" title="Permalink"></a></h2><p>Next, let&#39;s take a closer look at our custom labels in the plot that we just generated. For each vertex of the face, the sum of both distances on the second line of its label must be at least 6, since we know that there is no shorter path between the apices. In fact, there are (at least) two such shortest paths that traverse parts of the face: One of the apices of <code>s</code> actually is a vertex of the face, namely the first apex</p><pre><code class="language-julia hljs">apx</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Int64}:
   1
 100</code></pre><p>at index <code>1</code>. Start from there and take 3 steps to either <code>56</code> or <code>80</code>. Both vertices are at distance 3 from the second apex, as their labels tell us. The only two vertices that are not visited on either of those two paths are <code>155</code> and <code>156</code>, and they are also at distance 3 from the second apex.</p><p>So among the vertices of the face <code>15⁺ 19⁺ 21⁺</code>, there are two special subsets: One subset of vertices, let us call it <span>$V_1$</span>, is &quot;close&quot; to the first apex (namely, take <span>$V_1$</span> to be the apex <code>1</code> itself). The other subset <span>$V_2$</span> (the subset consisting of <code>56</code>, <code>155</code>, <code>156</code>, and <code>80</code>) is disjoint from the first one, and each vertex in <span>$V_2$</span> is &quot;close&quot; to the second apex . Here, &quot;close&quot; means that if we pick two arbitrary vertices, one from each subset, then the sum of their distances to the respectively closest apex is at most some given number <span>$k$</span>. In our case, any <span>$k \ge 3$</span> would work for this definition of being &quot;close&quot;, since the distance of <span>$V_1$</span> to <code>apx[1]</code> is 0 and that of any vertex in <span>$V_2$</span> to <code>apx[2]</code> is 3.</p><p>Let&#39;s visualize the two sets <span>$V_1$</span> and <span>$V_2$</span>. Again, we tweak the arguments passed to <code>plot</code> and label the vertices of the face by which set they belong to. For example, this can be achieved by</p><pre><code class="language-julia hljs">set_labels = map(1:nvertices(s)) do v
    if v == 1
        return &quot;$v ∈ V₁&quot;
    elseif v in [56, 155, 156, 80]
        return &quot;$v ∈ V₂&quot;
    else
        return &quot;$v&quot;  # default label for vertices in neither of the two sets
    end
end
plot(s, face; ineqlabels=nothing, vertexlabels=set_labels, usecoordinates=false, title=&quot;V₁ and V₂&quot;)</code></pre><img src="a5056d10.svg" alt="Example block output"/><p>Note that there are exactly two edges of the face <code>15⁺ 19⁺ 21⁺</code> whose endpoints belong to neither <span>$V_1$</span> nor <span>$V_2$</span> (and, hence, are only labeled by their index in the plot above). These edges are those between <code>25</code> and <code>57</code>, and between <code>33</code> and <code>81</code>. Let&#39;s mark them up in the plot using the keyword argument <code>markup_edges</code>:</p><pre><code class="language-julia hljs">plot(s, face;
    ineqlabels=nothing, vertexlabels=set_labels,
    markup_edges=([25,57], [33,81]),
    usecoordinates=false, title=&quot;V₁ and V₂&quot;
)</code></pre><img src="08e051af.svg" alt="Example block output"/><p>Not only are the two edges marked up in the plot, they are also drawn as <em>directed</em> edges now. To see why (and how this direction is determined by <code>plot</code>), let&#39;s look at the true geometry of the face <code>15⁺ 19⁺ 21⁺</code> again:</p><pre><code class="language-julia hljs">plot(s, face;
    ineqlabels=nothing, vertexlabels=set_labels,
    markup_edges=([25,57], [33,81]),
    usecoordinates=true, title=&quot;V₁ and V₂&quot;,
    xguide=&quot;&quot;, yguide=&quot;&quot;  # hide axis labels
)</code></pre><img src="accbd391.svg" alt="Example block output"/><p>Now the two arrows point away from each other – this is precisely how the <code>plot</code> command decides at which endpoints to place the arrow tips.</p><p>Yet what do these directions tell us? To explain this, recall that each of the highlighted edges belongs to a shortest path (of length 6) between the apices of <code>s</code>. For example, we saw above that there is path of length 3 between the second apex of <code>s</code> (the one not contained in the face) and the vertex <code>156</code> (since <code>156</code> is in <span>$V_2$</span>). From <code>156</code>, it&#39;s only 3 more edge steps to the first apex <code>1</code>. Now imagine that we travel along the edges of this path towards <code>1</code>, and orient each edge according to our direction of travel. Then the path becomes a sequence of steps in certain directions, where we follow each direction as far as we can – namely, until we hit the next vertex along the path.</p><p>What happens if we choose different directions at each step? For example, suppose that we have reached <code>156</code>, and now choose one of the two highlighted edge directions. To visualize the situation, we need a little extra code. First, let&#39;s define a function that, given a starting point <code>z</code> and a direction <code>g</code>, determines how far we can walk without leaving the face. In a formula, this is the maximum number <span>$\mu$</span> for which <span>$A(z+\mu g) \le b$</span> (note that the maximum is indeed finite because the spindle <code>s</code> is a polytope).</p><pre><code class="language-julia hljs">function maxsteplength(z, g)
    # ignore rows of A whose dot product with the given direction is &lt;= 0
    # since the corresponding inequalities will be satisfied for any positive step length
    divpos(x, y) = y &gt; 0 ? x/y : Inf
    minimum(divpos.(b - A * z, A * g))
end</code></pre><p>With this helper function, we can now visualize what happens after a hypothetical step along either of the two arrows. In fact, we just add to the previous plot by using <code>plot!</code> instead of <code>plot</code>.</p><pre><code class="language-julia hljs">edges = ((81,33), (57,25))  # the two edges marked up above
source = collect(vertices(s))[156]

for (u, v) in edges
    edge_direction = collect(vertices(s))[v] - collect(vertices(s))[u]
    μ = maxsteplength(source, edge_direction)
    destination = source + μ * edge_direction

    plot!(
        # project points onto the same two coordinates (1 and 5) as the face
        [source[1], destination[1]], [source[5], destination[5]],
        seriestype=:arrow, linestyle=:dash, linewidth=2, linecolor=:darkorange2,
    )
end
current()</code></pre><img src="68fed4a0.svg" alt="Example block output"/><div class="admonition is-info"><header class="admonition-header">Plotting arrows</header><div class="admonition-body"><p>The series type <code>arrow</code> is a custom series type defined by <em>Spindles.jl</em>.</p></div></div><p>The plot above tells us that either of the two dashed arrows (which are parallel to the marked up edges) leads us directly onto an edge that is incident with <code>1</code>, rather than taking the &quot;detour&quot; along edges. In a nutshell, this is the reason why the face <code>15⁺ 19⁺ 21⁺</code> is so interesting for analyzing paths on the spindle <code>s</code>: It allows for a &quot;shortcut&quot; when steps through the interior of the face are allowed. Note that the choice of the vertex <code>156</code> above was arbitrary. Indeed, we could translate the tails of the two dashed arrows over to any other vertex in <span>$V_2$</span> and still construct similar shortcuts on the face.</p><p>Let us call a 2-face of a spindle a <em>good 2-face</em> if it allows for such a shortcut between the apices as above (regardless of its direction). <em>Spindles.jl</em> provides a function <a href="../../man/goodfaces/#Spindles.isgood2face"><code>isgood2face</code></a> that tests a face for being good.</p><pre><code class="language-julia hljs">isgood2face(s, face, apx...)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Spindles.FaceState(true, [29, 37, 41], ([25, 57], [81, 33]), ([1], [56, 155, 156, 80]))</code></pre><p>The result is wrapped in a bespoke data type called <a href="../../man/goodfaces/#Spindles.FaceState"><code>FaceState</code></a>. The field <code>good</code> indicates whether or not the tested face is good, and the two vertex sets <span>$V_1$</span> and <span>$V_2$</span> that certify the property of being good are stored in the field <code>vsets</code> (see also the documentation on the <a href="../../man/goodfaces/#Spindles.FaceState"><code>FaceState</code></a> type):</p><pre><code class="language-julia hljs">fstate = isgood2face(s, face, apx...)
fstate.good, fstate.vsets</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(true, ([1], [56, 155, 156, 80]))</code></pre><p>Feel free to compare the output with the sets <span>$V_1$</span> and <span>$V_2$</span> that we identified above.</p><h2 id="Finding-all-good-2-faces"><a class="docs-heading-anchor" href="#Finding-all-good-2-faces">Finding all good 2-faces</a><a id="Finding-all-good-2-faces-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-all-good-2-faces" title="Permalink"></a></h2><p>Using the functions <a href="../../man/polytopes/combinatorics/#Spindles.Polytopes.facesofdim"><code>facesofdim</code></a> and <a href="../../man/goodfaces/#Spindles.isgood2face"><code>isgood2face</code></a>, all good 2-faces of <code>s</code> are easily enumerated.</p><pre><code class="language-julia hljs">for f in sort(facesofdim(s, 2))
    if isgood2face(s, f, apx...).good
        println(join(labels[f], &quot; &quot;))
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3⁺ 7⁺ 9⁺
3⁺ 7⁺ 9⁻
3⁺ 8⁺ 9⁺
3⁺ 8⁺ 9⁻
3⁻ 7⁻ 10⁺
3⁻ 7⁻ 10⁻
3⁻ 8⁻ 10⁺
3⁻ 8⁻ 10⁻
4⁺ 7⁺ 11⁺
4⁺ 7⁺ 11⁻
4⁺ 7⁻ 11⁺
4⁺ 7⁻ 11⁻
4⁻ 8⁺ 12⁺
4⁻ 8⁺ 12⁻
4⁻ 8⁻ 12⁺
4⁻ 8⁻ 12⁻
15⁺ 19⁺ 21⁺
15⁺ 19⁺ 21⁻
15⁺ 20⁺ 21⁺
15⁺ 20⁺ 21⁻
15⁻ 19⁻ 22⁺
15⁻ 19⁻ 22⁻
15⁻ 20⁻ 22⁺
15⁻ 20⁻ 22⁻
16⁺ 19⁺ 23⁺
16⁺ 19⁺ 23⁻
16⁺ 19⁻ 23⁺
16⁺ 19⁻ 23⁻
16⁻ 20⁺ 24⁺
16⁻ 20⁺ 24⁻
16⁻ 20⁻ 24⁺
16⁻ 20⁻ 24⁻</code></pre><p>In particular, for each good 2-face, there must exist paths from both apices to some vertex on the face of total length at most 3. Interestingly, all 2-faces of <code>s</code> that satisfy this weaker condition are good:</p><pre><code class="language-julia hljs">for f in sort(facesofdim(s, 2))
    min_total_length = sum(
        minimum(  # minimum distance of the apices to any vertex on the face
            dist(s, a, v) for v in incidentvertices(s, f)
        ) for a in apx
    )
    if min_total_length &lt;= 3
        println(join(labels[f], &quot; &quot;), &quot;\t&quot;, isgood2face(s, f, apx...).good)
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3⁺ 7⁺ 9⁺	true
3⁺ 7⁺ 9⁻	true
3⁺ 8⁺ 9⁺	true
3⁺ 8⁺ 9⁻	true
3⁻ 7⁻ 10⁺	true
3⁻ 7⁻ 10⁻	true
3⁻ 8⁻ 10⁺	true
3⁻ 8⁻ 10⁻	true
4⁺ 7⁺ 11⁺	true
4⁺ 7⁺ 11⁻	true
4⁺ 7⁻ 11⁺	true
4⁺ 7⁻ 11⁻	true
4⁻ 8⁺ 12⁺	true
4⁻ 8⁺ 12⁻	true
4⁻ 8⁻ 12⁺	true
4⁻ 8⁻ 12⁻	true
15⁺ 19⁺ 21⁺	true
15⁺ 19⁺ 21⁻	true
15⁺ 20⁺ 21⁺	true
15⁺ 20⁺ 21⁻	true
15⁻ 19⁻ 22⁺	true
15⁻ 19⁻ 22⁻	true
15⁻ 20⁻ 22⁺	true
15⁻ 20⁻ 22⁻	true
16⁺ 19⁺ 23⁺	true
16⁺ 19⁺ 23⁻	true
16⁺ 19⁻ 23⁺	true
16⁺ 19⁻ 23⁻	true
16⁻ 20⁺ 24⁺	true
16⁻ 20⁺ 24⁻	true
16⁻ 20⁻ 24⁺	true
16⁻ 20⁻ 24⁻	true</code></pre><p>If you would like to explore one of the actual counterexamples to the Hirsch conjecture that was built from a spindle like <code>s</code>, please read on <a href="../hirsch-ii/#Spindles-and-the-Hirsch-conjecture-II">here</a>.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../permutahedra/">« Line segments, hypercubes, and permutahedra</a><a class="docs-footer-nextpage" href="../hirsch-ii/">Spindles and the Hirsch conjecture II »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Monday 14 April 2025 11:17">Monday 14 April 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
