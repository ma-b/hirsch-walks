<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Spindles and the Hirsch conjecture I · Spindles.jl</title><meta name="title" content="Spindles and the Hirsch conjecture I · Spindles.jl"/><meta property="og:title" content="Spindles and the Hirsch conjecture I · Spindles.jl"/><meta property="twitter:title" content="Spindles and the Hirsch conjecture I · Spindles.jl"/><meta name="description" content="Documentation for Spindles.jl."/><meta property="og:description" content="Documentation for Spindles.jl."/><meta property="twitter:description" content="Documentation for Spindles.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Spindles.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../firststeps/">First steps</a></li><li class="is-active"><a class="tocitem" href>Spindles and the Hirsch conjecture I</a><ul class="internal"><li><a class="tocitem" href="#The-Hirsch-conjecture"><span>The Hirsch conjecture</span></a></li><li><a class="tocitem" href="#Reading-a-spindle-from-a-file"><span>Reading a spindle from a file</span></a></li><li><a class="tocitem" href="#Inspecting-faces"><span>Inspecting faces</span></a></li><li><a class="tocitem" href="#A-good-2-face"><span>A good 2-face</span></a></li><li><a class="tocitem" href="#Finding-all-good-2-faces"><span>Finding all good 2-faces</span></a></li></ul></li><li><a class="tocitem" href="../hirsch-ii/">Spindles and the Hirsch conjecture II</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../man/api/">Index</a></li><li><a class="tocitem" href="../../man/representation/">Representation</a></li><li><a class="tocitem" href="../../man/faces/">Faces</a></li><li><a class="tocitem" href="../../man/plots/">Plots</a></li><li><a class="tocitem" href="../../man/io/">File I/O</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Spindles and the Hirsch conjecture I</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Spindles and the Hirsch conjecture I</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ma-b/hirsch-walks" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ma-b/hirsch-walks/blob/main/Spindles/examples/hirsch-i.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Spindles-and-the-Hirsch-conjecture-I"><a class="docs-heading-anchor" href="#Spindles-and-the-Hirsch-conjecture-I">Spindles and the Hirsch conjecture I</a><a id="Spindles-and-the-Hirsch-conjecture-I-1"></a><a class="docs-heading-anchor-permalink" href="#Spindles-and-the-Hirsch-conjecture-I" title="Permalink"></a></h1><p><a href="https://nbviewer.jupyter.org/github/ma-b/hirsch-walks/blob/gh-pages/dev/tutorials/Spindles and the Hirsch conjecture I.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><p>In this tutorial, we will explore a particular spindle that is known from theory to have an interesting property: Its apices are far away from each other in the graph of the spindle. This property made it possible to disprove a long-standing conjecture in polyhedral theory, the so-called <em>Hirsch conjecture</em>. Even though the focus of this tutorial is on a thorough analysis of the special spindle, we will showcase some more advanced functionalities and customization options of <em>Spindles.jl</em> along the way. For the basic usage, please read <a href="../firststeps/#First-steps">this tutorial</a> first.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This tutorial is also available as a Jupyter notebook. Click on the badge above to view it in <a href="https://nbviewer.jupyter.org/">nbviewer</a>.</p></div></div><h2 id="The-Hirsch-conjecture"><a class="docs-heading-anchor" href="#The-Hirsch-conjecture">The Hirsch conjecture</a><a id="The-Hirsch-conjecture-1"></a><a class="docs-heading-anchor-permalink" href="#The-Hirsch-conjecture" title="Permalink"></a></h2><p>The <a href="https://en.wikipedia.org/wiki/Hirsch_conjecture">Hirsch conjecture</a> for polytopes stated that any two vertices of a <span>$d$</span>-dimensional polytope with <span>$f$</span> facets can be connected by a path of at most <span>$f-d$</span> edges. It was disproved in 2010 when Francisco Santos found a <a href="https://arxiv.org/abs/1006.2814">construction</a> that produces counterexamples from spindles with a special property: the length of a shortest path between the apices (called the <em>length</em> of the spindle) must be strictly greater than the dimension.</p><p>Santos&#39; original counterexample from 2010 is based on a 5-dimensional spindle with 48 facets, for which the shortest path between the apices is of length 6. A minimal inequality description of this spindle (see Table 1 in Santos&#39; <a href="https://arxiv.org/pdf/1006.2814">paper</a>) can be found in the file <code>s-48-5.txt</code> located in the <code>examples</code> folder beneath the package root directory <code>Spindles</code>.</p><h2 id="Reading-a-spindle-from-a-file"><a class="docs-heading-anchor" href="#Reading-a-spindle-from-a-file">Reading a spindle from a file</a><a id="Reading-a-spindle-from-a-file-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-a-spindle-from-a-file" title="Permalink"></a></h2><p>We may read the description from the file as follows.</p><pre><code class="language-julia hljs">using Spindles
A, b, labels = readineq(&quot;../../../examples/s-48-5.txt&quot;, Int);</code></pre><pre><code class="language-julia hljs">[A b]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">48×6 Matrix{Rational{Int64}}:
  1   18    0    0    0  1
  1  -18    0    0    0  1
  1    0   18    0    0  1
  1    0  -18    0    0  1
  1    0    0   45    0  1
  1    0    0  -45    0  1
  1    0    0    0   45  1
  1    0    0    0  -45  1
  1   15   15    0    0  1
  1  -15   15    0    0  1
  ⋮                      ⋮
 -1  -30  -30    0    0  1
 -1   40    0   10    0  1
 -1   40    0  -10    0  1
 -1  -40    0   10    0  1
 -1  -40    0  -10    0  1
 -1    0   40    0   10  1
 -1    0   40    0  -10  1
 -1    0  -40    0   10  1
 -1    0  -40    0  -10  1</code></pre><p>The function <a href="../../man/io/#Spindles.readineq"><code>readineq</code></a> does not only return the data in the inequality description <span>$Ax \le b$</span> from the source but also the attached labels, one for each inequality.</p><pre><code class="language-julia hljs">labels</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">48-element Vector{String}:
 &quot;1⁺&quot;
 &quot;1⁻&quot;
 &quot;2⁺&quot;
 &quot;2⁻&quot;
 &quot;3⁺&quot;
 &quot;3⁻&quot;
 &quot;4⁺&quot;
 &quot;4⁻&quot;
 &quot;5⁺&quot;
 &quot;5⁻&quot;
 ⋮
 &quot;20⁻&quot;
 &quot;21⁺&quot;
 &quot;21⁻&quot;
 &quot;22⁺&quot;
 &quot;22⁻&quot;
 &quot;23⁺&quot;
 &quot;23⁻&quot;
 &quot;24⁺&quot;
 &quot;24⁻&quot;</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Even though we use the same set of labels as Santos in his <a href="https://arxiv.org/pdf/1006.2814">paper</a>, the assignment to the rows of <code>A</code> is different.</p></div></div><p>The resulting spindle <code>s</code> has</p><pre><code class="language-julia hljs">s = Spindle(A, b)
nvertices(s)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">322</code></pre><p>vertices and its apices are</p><pre><code class="language-julia hljs">collect(vertices(s))[apices(s)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Vector{Rational{Int64}}}:
 [-1, 0, 0, 0, 0]
 [1, 0, 0, 0, 0]</code></pre><p>The distance between them in the graph of <code>s</code> is indeed 6:</p><pre><code class="language-julia hljs">dist(s, apices(s)...)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6</code></pre><p>Note that both apices are highly degenerate:</p><pre><code class="language-julia hljs">using Graphs: degree
degree(graph(s), apices(s))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Int64}:
 32
 32</code></pre><h2 id="Inspecting-faces"><a class="docs-heading-anchor" href="#Inspecting-faces">Inspecting faces</a><a id="Inspecting-faces-1"></a><a class="docs-heading-anchor-permalink" href="#Inspecting-faces" title="Permalink"></a></h2><p>The original motivation for developing <em>Spindles.jl</em> was the search for special two-dimensional faces (or <em>2-faces</em> for short) of the spindle <code>s</code> and similar spindles. To explain what we mean by &quot;special&quot;, let us consider the following three facets (note that all inequalities in the description given in <code>s-48-5.txt</code> are indeed facet-defining):</p><pre><code class="language-julia hljs">face = [29, 37, 41]
labels[face]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{String}:
 &quot;15⁺&quot;
 &quot;19⁺&quot;
 &quot;21⁺&quot;</code></pre><p>They indeed define a 2-face of <code>s</code>:</p><pre><code class="language-julia hljs">face in facesofdim(s, 2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>To inspect <code>face</code>, we may use the function <a href="../../man/plots/#Spindles.plot2face"><code>plot2face</code></a> provided by <em>Spindles.jl</em> to make a plot.</p><pre><code class="language-julia hljs">plot2face(s, face; ineqlabels=labels)</code></pre><img src="92fb83af.svg" alt="Example block output"/><p>Each vertex is labeled by its index. Edges and the face itself get their labels from the incident facets, since we passed the <code>labels</code> extracted above to the keyword argument <code>ineqlabels</code>. Note here that the three facets that contain <code>face</code> are omitted from the edge labels.</p><p>We may customize the above plot even further. For example, let&#39;s add more information to the vertex labels. To print the distances of each vertex to the two apices of <code>s</code> on a second line beneath the vertex index, we first generate all labels in the desired format. Here, we use the format <code>&quot;dist1 | dist2&quot;</code> for the second line of the label, where <code>dist1</code> and <code>dist2</code> are placeholders for the distances to <code>apices(s)[1]</code> and <code>apices(s)[2]</code>, respectively.</p><pre><code class="language-julia hljs">dist_labels = map(1:nvertices(s)) do v
    &quot;$v\n&quot; * join(dist.((s,), apices(s), v), &quot; | &quot;)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">322-element Vector{String}:
 &quot;1\n0 | 6&quot;
 &quot;2\n1 | 5&quot;
 &quot;3\n1 | 5&quot;
 &quot;4\n1 | 5&quot;
 &quot;5\n1 | 5&quot;
 &quot;6\n1 | 5&quot;
 &quot;7\n1 | 5&quot;
 &quot;8\n1 | 5&quot;
 &quot;9\n1 | 5&quot;
 &quot;10\n1 | 5&quot;
 ⋮
 &quot;314\n5 | 1&quot;
 &quot;315\n5 | 1&quot;
 &quot;316\n5 | 1&quot;
 &quot;317\n5 | 1&quot;
 &quot;318\n5 | 1&quot;
 &quot;319\n5 | 1&quot;
 &quot;320\n5 | 1&quot;
 &quot;321\n5 | 1&quot;
 &quot;322\n5 | 1&quot;</code></pre><div class="admonition is-info"><header class="admonition-header">Julia syntax</header><div class="admonition-body"><pre><code class="language-julia hljs">dist.((s,), apices(s), v)</code></pre><p>is a shorthand for</p><pre><code class="language-julia hljs">[dist(s, apex, v) for apex in apices(s)]</code></pre><p>Wrapping <code>s</code> in a tuple makes sure that the Julia &quot;broadcast dot&quot; is only applied to the second argument of <code>dist</code>, namely <code>apices(s)</code>, and not to the first argument <code>s</code> (which is not iterable).</p></div></div><p>Our custom vertex labels can now be passed to <code>plot2face</code> as follows:</p><pre><code class="language-julia hljs">plot2face(s, face; ineqlabels=labels, vertexlabels=dist_labels, usecoordinates=false)</code></pre><img src="deffa225.svg" alt="Example block output"/><p>Note here that the (optional) additional argument <code>usecoordinates=false</code> changed the plot mode to a (combinatorial) drawing of the graph of the face <code>15+ 19+ 21+</code> rather than a planar projection of its true coordinates as above.</p><h2 id="A-good-2-face"><a class="docs-heading-anchor" href="#A-good-2-face">A good 2-face</a><a id="A-good-2-face-1"></a><a class="docs-heading-anchor-permalink" href="#A-good-2-face" title="Permalink"></a></h2><p>Next, let&#39;s take a closer look at our custom labels in the plot that we just generated. For each vertex of the face, the sum of both distances on the second line of its label must be at least 6, since we know that there is no shorter path between the apices. In fact, there are (at least) two such shortest paths that traverse parts of the face: One of the apices of <code>s</code> actually is a vertex of the face, namely the first apex</p><pre><code class="language-julia hljs">apices(s)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Int64}:
   1
 100</code></pre><p>at index <code>1</code>. Start from there and take 3 steps to either <code>56</code> or <code>80</code>. Both vertices are at distance 3 from the second apex, as their labels tell us. The only two vertices that are not visited on either of those two paths are <code>155</code> and <code>156</code>, and they are also at distance 3 from the second apex.</p><p>So among the vertices of the face <code>15+ 19+ 21+</code>, there are two special subsets: One subset of vertices, let us call it <span>$V_1$</span>, is &quot;close&quot; to the first apex (namely, take <span>$V_1$</span> to be the apex <code>1</code> itself). The other subset <span>$V_2$</span> (the subset consisting of <code>56</code>, <code>155</code>, <code>156</code>, and <code>80</code>) is disjoint from the first one, and each vertex in <span>$V_2$</span> is &quot;close&quot; to the second apex . Here, &quot;close&quot; means that if we pick two arbitrary vertices, one from each subset, then the sum of their distances to the respectively closest apex is at most some given number <span>$k$</span>. In our case, any <span>$k \ge 3$</span> would work for this definition of being &quot;close&quot;, since the distance of <span>$V_1$</span> to <code>apices(s)[1]</code> is 0 and that of any vertex in <span>$V_2$</span> to <code>apices(s)[2]</code> is 3.</p><p>Let&#39;s visualize the two sets <span>$V_1$</span> and <span>$V_2$</span>. Again, we tweak the arguments passed to <code>plot2face</code> and label the vertices of the face by which set they belong to. For example, this can be achieved by</p><pre><code class="language-julia hljs">set_labels = map(1:nvertices(s)) do v
    if v == 1
        return &quot;$v ∈ V₁&quot;
    elseif v in [56, 155, 156, 80]
        return &quot;$v ∈ V₂&quot;
    else
        return &quot;$v&quot;  # default label for vertices in neither of the two sets
    end
end
plot2face(s, face; ineqlabels=nothing, vertexlabels=set_labels, usecoordinates=false, title=&quot;V₁ and V₂&quot;)</code></pre><img src="dd86b708.svg" alt="Example block output"/><p>Note that there are exactly two edges of the face <code>15+ 19+ 21+</code> whose endpoints do not belong to neither <span>$V_1$</span> nor <span>$V_2$</span> (and, hence, are only labeled by their index in the plot above). These edges are those between <code>25</code> and <code>57</code>, and between <code>33</code> and <code>81</code>. Let&#39;s mark them up in the plot using the keyword argument <code>directed_edges</code>:</p><pre><code class="language-julia hljs">plot2face(s, face;
    ineqlabels=nothing, vertexlabels=set_labels,
	directed_edges=([25,57], [33,81]),
    usecoordinates=false, title=&quot;V₁ and V₂&quot;
)</code></pre><img src="225c9115.svg" alt="Example block output"/><p>Not only are the two edges marked up in the plot, they are also drawn as <em>directed</em> edges now. To see why (and how this direction is determined by <code>plot2face</code>), recall that each of them is contained in a shortest path between the apices of <code>s</code> that walks along parts of the face <code>15+ 19+ 21+</code>. For example, coming from the second apex (the one not contained in the face) and heading towards the first apex <code>1</code>, the two red edges are traversed in exactly the direction indicated above. If we look at the &quot;true&quot; geometry of <code>15+ 19+ 21+</code>, though, we could also start from any vertex in <span>$V_2$</span> and follow one of the two red arrows (through the interior of the face!) as far as possible without leaving the face.</p><pre><code class="language-julia hljs">plot2face(s, face;
    ineqlabels=nothing, vertexlabels=set_labels,
	directed_edges=([25,57], [33,81]),
    usecoordinates=true, title=&quot;V₁ and V₂&quot;
)</code></pre><img src="f2385c2f.svg" alt="Example block output"/><p>The geometry of the 2-face tells us that the point on the boundary that we hit must be on one of the two edges incident to the apex <code>1</code>. From that point, we walk along the edge and reach <code>1</code> within (at most) two steps on the face, rather than three steps along its boundary. So, in a relaxed regime where paths may pass through the interior of a face, one might consider taking three edges steps from the second apex to some vertex in <span>$V_2$</span>, then apply the two-step &quot;shortcut&quot; through the interior of the face <code>15+ 19+ 21+</code>, and end up at the first apex <code>1</code>. This yields (at most) 5 steps in total. Recall that in the traditional regime where paths through the interior are forbidden, one cannot do better than 6 steps.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is important to note here that, unlike paths along edges, this shortcut has a direction associated to it. The direction is determined by the geometry of the 2-face <code>15+ 19+ 21+</code> and is indicated by the direction of the two red edges. When making a plot with <code>plot2face</code> as above, they are always drawn in such a way that the arrows &quot;point away&quot; from each other.</p></div></div><p>Shortcuts like this are precisely what makes faces such as <code>15+ 19+ 21+</code> interesting for analyzing <code>s</code> in the setting of the so-called <em>circuit diameter conjecture</em>, a relaxation of the Hirsch conjecture that allows for paths through the interior of a polytope.</p><p>Let us call a 2-face of a spindle a <em>good 2-face</em> if it allows for such a shortcut between the apices as above (regardless of its direction). <em>Spindles.jl</em> provides a function <a href="../../man/faces/#Spindles.isgood2face"><code>isgood2face</code></a> that tests a face for being good.</p><pre><code class="language-julia hljs">isgood2face(s, face)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Spindles.FaceState(true, [29, 37, 41], ([25, 57], [81, 33]), ([1], [56, 155, 156, 80]))</code></pre><p>The result is wrapped in a bespoke data type called <a href="../../man/faces/#Spindles.FaceState"><code>FaceState</code></a>. The field <code>good</code> indicates whether or not the tested face is good, and the two vertex sets <span>$V_1$</span> and <span>$V_2$</span> that certify the property of being good are stored in the field <code>vsets</code> (see also the documentation on the <a href="../../man/faces/#Spindles.FaceState"><code>FaceState</code></a> type):</p><pre><code class="language-julia hljs">fstate = isgood2face(s, face)
fstate.good, fstate.vsets</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(true, ([1], [56, 155, 156, 80]))</code></pre><p>Feel free to compare the output with the sets <span>$V_1$</span> and <span>$V_2$</span> that we identified above.</p><h2 id="Finding-all-good-2-faces"><a class="docs-heading-anchor" href="#Finding-all-good-2-faces">Finding all good 2-faces</a><a id="Finding-all-good-2-faces-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-all-good-2-faces" title="Permalink"></a></h2><p>Using <a href="../../man/faces/#Spindles.isgood2face"><code>isgood2face</code></a>, all good 2-faces of <code>s</code> are easily enumerated.</p><pre><code class="language-julia hljs">for f in sort(facesofdim(s, 2))
    if isgood2face(s, f).good
        println(join(labels[f], &quot; &quot;))
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3⁺ 7⁺ 9⁺
3⁺ 7⁺ 9⁻
3⁺ 8⁺ 9⁺
3⁺ 8⁺ 9⁻
3⁻ 7⁻ 10⁺
3⁻ 7⁻ 10⁻
3⁻ 8⁻ 10⁺
3⁻ 8⁻ 10⁻
4⁺ 7⁺ 11⁺
4⁺ 7⁺ 11⁻
4⁺ 7⁻ 11⁺
4⁺ 7⁻ 11⁻
4⁻ 8⁺ 12⁺
4⁻ 8⁺ 12⁻
4⁻ 8⁻ 12⁺
4⁻ 8⁻ 12⁻
15⁺ 19⁺ 21⁺
15⁺ 19⁺ 21⁻
15⁺ 20⁺ 21⁺
15⁺ 20⁺ 21⁻
15⁻ 19⁻ 22⁺
15⁻ 19⁻ 22⁻
15⁻ 20⁻ 22⁺
15⁻ 20⁻ 22⁻
16⁺ 19⁺ 23⁺
16⁺ 19⁺ 23⁻
16⁺ 19⁻ 23⁺
16⁺ 19⁻ 23⁻
16⁻ 20⁺ 24⁺
16⁻ 20⁺ 24⁻
16⁻ 20⁻ 24⁺
16⁻ 20⁻ 24⁻</code></pre><p>In particular, for each good 2-face, there must exist paths from both apices to some vertex on the face of total length at most 3. Interestingly, all 2-faces of <code>s</code> that satisfy this weaker condition are good:</p><pre><code class="language-julia hljs">for f in sort(facesofdim(s, 2))
    min_total_length = sum(
        minimum(
            dist(s, a, v) for v in incidentvertices(s, f)
        ) for a in apices(s)
    )
    if min_total_length &lt;= 3
        println(join(labels[f], &quot; &quot;), &quot;\t&quot;, isgood2face(s, f).good)
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3⁺ 7⁺ 9⁺	true
3⁺ 7⁺ 9⁻	true
3⁺ 8⁺ 9⁺	true
3⁺ 8⁺ 9⁻	true
3⁻ 7⁻ 10⁺	true
3⁻ 7⁻ 10⁻	true
3⁻ 8⁻ 10⁺	true
3⁻ 8⁻ 10⁻	true
4⁺ 7⁺ 11⁺	true
4⁺ 7⁺ 11⁻	true
4⁺ 7⁻ 11⁺	true
4⁺ 7⁻ 11⁻	true
4⁻ 8⁺ 12⁺	true
4⁻ 8⁺ 12⁻	true
4⁻ 8⁻ 12⁺	true
4⁻ 8⁻ 12⁻	true
15⁺ 19⁺ 21⁺	true
15⁺ 19⁺ 21⁻	true
15⁺ 20⁺ 21⁺	true
15⁺ 20⁺ 21⁻	true
15⁻ 19⁻ 22⁺	true
15⁻ 19⁻ 22⁻	true
15⁻ 20⁻ 22⁺	true
15⁻ 20⁻ 22⁻	true
16⁺ 19⁺ 23⁺	true
16⁺ 19⁺ 23⁻	true
16⁺ 19⁻ 23⁺	true
16⁺ 19⁻ 23⁻	true
16⁻ 20⁺ 24⁺	true
16⁻ 20⁺ 24⁻	true
16⁻ 20⁻ 24⁺	true
16⁻ 20⁻ 24⁻	true</code></pre><p>If you would like to explore one of the actual counterexamples to the Hirsch conjecture that was built from a spindle like <code>s</code>, please read on <a href="../hirsch-ii/#Spindles-and-the-Hirsch-conjecture-II">here</a>.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../firststeps/">« First steps</a><a class="docs-footer-nextpage" href="../hirsch-ii/">Spindles and the Hirsch conjecture II »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Saturday 15 February 2025 18:34">Saturday 15 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
