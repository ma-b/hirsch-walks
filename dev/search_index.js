var documenterSearchIndex = {"docs":
[{"location":"man/io/#File-I/O","page":"File I/O","title":"File I/O","text":"","category":"section"},{"location":"man/io/","page":"File I/O","title":"File I/O","text":"writeineq\nreadineq","category":"page"},{"location":"man/io/#Spindles.writeineq","page":"File I/O","title":"Spindles.writeineq","text":"writeineq(fname, A::AbstractMatrix, b::AbstractVector [, rowlabels];\n    labels=true, comments=[], comment_char='#'\n)\n\nWrite the coefficient matrix A and the vector of right-hand sides b of a system of linear inequalities to the file fname.\n\nThe file format is [rowlabels b -A] where rowlabels is a vector of strings, or just [b -A] (without a label column) if labels is false.\n\nIf no rowlabels are provided and labels is true, use the row indices as default labels.\n\nSee also readineq.\n\nKeywords\n\nlabels: If true (default), print a first column with row labels as given by the argument rowlabels. If rowlabels is unspecified, each row is labeled by its index (ranging from 1 to the number of rows of A).\ncomments: A vector of strings.  Each element in comments will be printed on its own line, following a comment_char  and a whitespace. Possible internal line breaks are ignored. The data A and b is  printed below the last line of comments.\ncomment_char: An AbstractChar that indicates the start of a comment line (default is '#').\n\nExamples\n\njulia> A = [1 0; 0 1; -1 0; 0 -1];\n\njulia> b = [1, 1, 1, 1];\n\njulia> labels = [\"α\", \"β\", \"γ\", \"δ\"];\n\njulia> writeineq(\"ineq.txt\", A, b, labels; comments=[\"A nice polytope\"])\n\njulia> print(read(\"ineq.txt\", String))\n# A nice polytope\nα  1  -1   0\nβ  1   0  -1\nγ  1   1   0\nδ  1   0   1\n\njulia> A, b, labels = readineq(\"ineq.txt\", Int);\n\njulia> A\n4×2 Matrix{Rational{Int64}}:\n  1   0\n  0   1\n -1   0\n  0  -1\n\njulia> b\n4-element Vector{Rational{Int64}}:\n 1\n 1\n 1\n 1\n\njulia> labels\n4-element Vector{String}:\n \"α\"\n \"β\"\n \"γ\"\n \"δ\"\n\njulia> rm(\"ineq.txt\")\n\n\n\n\n\n","category":"function"},{"location":"man/io/#Spindles.readineq","page":"File I/O","title":"Spindles.readineq","text":"readineq(fname, T; labels=true, comment_char='#')\n\nRead A, b, labels from file fname. The element type of A and b is Rational{T}.\n\nLines starting with a comment_char character and all characters on a line following  a comment_char are ignored.\n\nSee also writeineq.\n\nKeywords\n\nlabels:\ncomment_char: \n\n\n\n\n\n","category":"function"},{"location":"man/spindles/#Spindles","page":"Spindles","title":"Spindles","text":"","category":"section"},{"location":"man/spindles/","page":"Spindles","title":"Spindles","text":"Spindles are special polytopes for which each facet is incident to exactly one of two special vertices.","category":"page"},{"location":"man/spindles/","page":"Spindles","title":"Spindles","text":"apices","category":"page"},{"location":"man/spindles/#Spindles.apices","page":"Spindles","title":"Spindles.apices","text":"apices(p::Polytope [, apex::Int]; checkredund=true)\n\nCheck whether p is a spindle, i.e., whether there is a pair of vertices (the apices) for which each facet of p is incident to exactly one of them. If p has a pair of apices, return their indices; otherwise return nothing.\n\nThe optional argument apex specifies the index of a vertex that is to be taken as one of the apices.\n\nKeywords\n\ncheckredund::Bool: If true (default), first detect all inequalities in the description of p    that are not facet-defining for p.    If p was created from an inequality description that is known to be minimal, this step may be skipped   by setting checkredund to false.\n\nnote: Note\nIn the presence of redundant inequalities, disabling checkredund can only produce false negatives:  Whenever apices returns a pair of vertices, they are guaranteed to be apices of p. The converse, however, is not necessarily true. A spindle may not be detected as such if its inequality description contains inequalities that are not facet-defining.\n\nExamples\n\njulia> p = Polytope([1 0; 0 1; -1 0; 0 -1], [1, 1, 1, 1]);\n\njulia> vertices(p)\n4-element iterator of Vector{Rational{BigInt}}:\n Rational{BigInt}[-1, -1]\n Rational{BigInt}[1, -1]\n Rational{BigInt}[-1, 1]\n Rational{BigInt}[1, 1]\n\njulia> apices(p)\n2-element Vector{Int64}:\n 1\n 4\n\njulia> apices(p, 2)\n2-element Vector{Int64}:\n 2\n 3\n\n\n\n\n\n","category":"function"},{"location":"man/api/#API-Index","page":"Index","title":"API Index","text":"","category":"section"},{"location":"man/api/","page":"Index","title":"Index","text":"Spindles","category":"page"},{"location":"man/api/#Spindles","page":"Index","title":"Spindles","text":"Main module. The public API is listed below.\n\n\n\n\n\n","category":"module"},{"location":"man/api/#Exports","page":"Index","title":"Exports","text":"","category":"section"},{"location":"man/api/","page":"Index","title":"Index","text":"","category":"page"},{"location":"man/polytopes/#Polytopes","page":"Polytopes","title":"Polytopes","text":"","category":"section"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"DocTestSetup = quote\n    import Polyhedra\n    using Spindles\nend","category":"page"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"The main type defined by Spindles.jl is the type Polytope that represents a polytope. Objects of this type are constructed either from a V-representation (a list of points whose convex hull is the polytope) or from an H-representation (a system of linear inequalities whose set of solutions is the polytope):","category":"page"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"Polytope","category":"page"},{"location":"man/polytopes/#Spindles.Polytope","page":"Polytopes","title":"Spindles.Polytope","text":"Polytope(V::AbstractVector{AbstractVector})\n\nCreate a polytope from the convex hull of the collection of points V.\n\n\n\n\n\nPolytope(V::AbstractMatrix)\n\nCreate a polytope from the convex hull of the rows of V.\n\n\n\n\n\nPolytope(A::AbstractMatrix, b::AbstractVector)\n\nCreate a polytope from its H-representation Ax le b.  If the polyhedron defined by Ax le b is unbounded, throw an error.\n\n\n\n\n\n","category":"type"},{"location":"man/polytopes/#Examples","page":"Polytopes","title":"Examples","text":"","category":"section"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"julia> p = Polytope([[0, 0], [1, 0], [0, 1], [1, 1]])\nPolytope{Rational{BigInt}}","category":"page"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"creates the polytope with vertices (00)(10)(01), and (11) (the two-dimensional 0/1 cube). This is the same as","category":"page"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"julia> q = Polytope([0 0; 1 0; 0 1; 1 1])\nPolytope{Rational{BigInt}}\n\njulia> p == q\ntrue","category":"page"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"note: Note\nTwo Polytopes are considered equal by the == operator if and only if they have the same set of vertices.","category":"page"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"An equivalent description of the 2D polytope p is in terms of the following system of linear inequalities:","category":"page"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"beginaligned\n0 le x_1 le 1 \n0 le x_2 le 1\nendaligned","category":"page"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"This translates to","category":"page"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"julia> A = [ -1   0\n              1   0\n              0  -1\n              0   1 ];\n\njulia> b = [0, 1, 0, 1];\n\njulia> r = Polytope(A, b)\nPolytope{Rational{BigInt}}\n\njulia> p == r\ntrue","category":"page"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"Unlike for the first two constructors above, there is no guarantee that a polyhedron defined by  a general system Ax le b is bounded (and, hence, a polytope). Indeed,  if we drop any of the four inequalities above – say the last one –, this property is lost:","category":"page"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"julia> Polytope(A[1:3,:], b[1:3])\nERROR: ArgumentError: got an unbounded polyhedron\n[...]","category":"page"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"Even though all examples so far only featured minimal descriptions of the two-dimensional 0/1 cube, a Polytope object can be created from any description of the polytope, not necessarily a minimal one. In particular, the list of points whose convex hull is the polytope can include non-vertices. Likewise, redundant inequalities and implicit equations in a system of linear inequalities are permitted.  Such redundancy can be detected, see Minimal representations.","category":"page"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"note: Type parameter\nPolytope is a parametric type. Namely, the precise type of each of the three objects constructed above is Polytope{Rational{BigInt}}, where the parameter Rational{BigInt} is called the element type and is inferred from the type of the data passed to the constructor. For example, Rational{BigInt} indicates that Polytope uses exact rational arithmetic to store and manipulate the coefficients in a V- or H-representation. For integer data, this is the default choice. Suppose that we change some of the input data above to floating-point numbers, such asjulia> Polytope([-1.0 0.0; 1 0; 0 -1; 0 1], [0, 1, 0, 1])\nPolytope{Float64}Then we get a different element type, namely Float64. The type of arithmetic used to represent and manipulate the Polytope object can also be set using an optional constructor argument that is borrowed from Polyhedra.jl (and that may be passed to any of the Polytope constructors):julia> using Polyhedra: DefaultLibrary\n\njulia> Polytope([-1.0 0.0; 1 0; 0 -1; 0 1], [0, 1, 0, 1], DefaultLibrary{Rational{BigInt}}())\nPolytope{Rational{BigInt}}This argument now specifies a library for polyhedral computations (the \"backend\" of Polyhedra.jl) that is to be used for the internal representation of the Polytope object. In this case, we chose the default library implemented in Polyhedra.jl but forced rational data instead of Floats.See also the JuliaPolyhedra website for a list of all supported libraries. For example, to use CDDLib with exact rational arithmetic, doimport CDDLib\nPolytope(A, b, CDDLib.Library(:exact))","category":"page"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"DocTestSetup = nothing","category":"page"},{"location":"man/representation/#Minimal-representations","page":"Minimal representations","title":"Minimal representations","text":"","category":"section"},{"location":"man/representation/","page":"Minimal representations","title":"Minimal representations","text":"DocTestSetup = quote\n    using Spindles\nend","category":"page"},{"location":"man/representation/","page":"Minimal representations","title":"Minimal representations","text":"We saw that a Polytope may be created from either a V- or a H-representation. However, these representations  need not be minimal. Which points or inequalities from the given description suffice can be detected with  the following functions.","category":"page"},{"location":"man/representation/#Vertices","page":"Minimal representations","title":"Vertices","text":"","category":"section"},{"location":"man/representation/","page":"Minimal representations","title":"Minimal representations","text":"To express a polytope as the convex hull of some finite set of points, the set of its vertices suffices.","category":"page"},{"location":"man/representation/","page":"Minimal representations","title":"Minimal representations","text":"Spindles.vertices\nnvertices","category":"page"},{"location":"man/representation/#Spindles.vertices","page":"Minimal representations","title":"Spindles.vertices","text":"vertices(p::Polytope)\n\nReturn an iterator over the vertices of the polytope p.\n\nExamples\n\njulia> p = Polytope([    1     0\n                         0     1\n                         0     1\n                      1//2  1//2 ]);\n\njulia> collect(vertices(p))\n2-element Vector{Vector{Rational{Int64}}}:\n [1, 0]\n [0, 1]\n\n\n\n\n\n","category":"function"},{"location":"man/representation/#Spindles.nvertices","page":"Minimal representations","title":"Spindles.nvertices","text":"nvertices(p::Polytope)\n\nCount the vertices of p.\n\n\n\n\n\n","category":"function"},{"location":"man/representation/","page":"Minimal representations","title":"Minimal representations","text":"The function vertices is also used to test two polytopes for equality:","category":"page"},{"location":"man/representation/","page":"Minimal representations","title":"Minimal representations","text":"==","category":"page"},{"location":"man/representation/#Base.:==","page":"Minimal representations","title":"Base.:==","text":"==(p::Polytope, q::Polytope)\n\nCheck whether the sets of vertices of p and q are identical.\n\nExamples\n\njulia> Polytope([1 0; 0 1]) == Polytope([1 0; 0 1; 0 1; 1//2 1//2])\ntrue\n\njulia> p = Polytope([-1 0; 0 -1; 2 1], [0, 0, 3]);\n\njulia> p == Polytope(collect(vertices(p)))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/representation/#Redundancy-and-implicit-equations","page":"Minimal representations","title":"Redundancy and implicit equations","text":"","category":"section"},{"location":"man/representation/","page":"Minimal representations","title":"Minimal representations","text":"A redundant inequality is one whose deletion leaves the polytope unchanged. If an inequality is satisfied  at equality by all points in the polytope, it is said to be an implicit equation.  Thus, the inequalities in a given description of a polytope may be partitioned into three sets:","category":"page"},{"location":"man/representation/","page":"Minimal representations","title":"Minimal representations","text":"a minimal set of facet-defining inequalities (which may not be unique!), \na (possibly empty) set of implicit equations contained in the inequality system, and \nall remaining inequalities (that may safely be deleted). ","category":"page"},{"location":"man/representation/","page":"Minimal representations","title":"Minimal representations","text":"This partition can be computed using the functions facets and impliciteqs, which return the first two classes of the partition.","category":"page"},{"location":"man/representation/","page":"Minimal representations","title":"Minimal representations","text":"facets\nnfacets\nimpliciteqs","category":"page"},{"location":"man/representation/#Spindles.facets","page":"Minimal representations","title":"Spindles.facets","text":"facets(p::Polytope)\n\nReturn a minimal subset of inequality indices that contains one inequality for each facet of p.\n\nIf multiple inequalities in the description of p define the same facet, the one with the smallest index is selected.\n\nSee also nfacets, impliciteqs.\n\nExamples\n\njulia> A = [-1 0; 1 0; 0 -1; 0 1]; b = [0, 1, 0, 1];\n\njulia> p = Polytope(A, b);\n\ncreates the polytope defined by the system\n\nbeginaligned\n0 le x_1 le 1 \n0 le x_2 le 1\nendaligned\n\nThe following inequalities are also valid for p:\n\nbeginaligned\n3 x_1 le 3 \nx_1 + x_2 le 2\nendaligned\n\nAdding them to the original (irredundant) system introduces redundancy:\n\njulia> B = [3 0; 1 1; A]; d = [3; 2; b];\n\njulia> q = Polytope(B, d);\n\njulia> f = facets(q)\n4-element Vector{Int64}:\n 1\n 3\n 5\n 6\n\njulia> r = Polytope(B[f,:], d[f]);\n\njulia> p == q == r\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/representation/#Spindles.nfacets","page":"Minimal representations","title":"Spindles.nfacets","text":"nfacets(p::Polytope)\n\nCount the facets of p. Shorthand for length(facets(p)).\n\nSee also nfacesofdim, facets.\n\n\n\n\n\n","category":"function"},{"location":"man/representation/#Spindles.impliciteqs","page":"Minimal representations","title":"Spindles.impliciteqs","text":"impliciteqs(p::Polytope)\n\nReturn the indices of all inequalities that are implicit equations, i.e., that are satisfied at equality for each point in p.\n\nSee also facets.\n\nExamples\n\nThe polytope given by\n\nbeginaligned\n0 le x_1 le 1 \nx_2 = 0\nendaligned\n\ncan be modeled by replacing the equality constraint with two inequalities pm x_2 le 0 as follows:\n\njulia> A = [-1 0; 1 0; 0 -1; 0 1]; b = [0, 1, 0, 0];\n\njulia> p = Polytope(A, b);\n\njulia> impliciteqs(p)\n2-element Vector{Int64}:\n 3\n 4\n\n\n\n\n\n","category":"function"},{"location":"man/representation/#Incidence","page":"Minimal representations","title":"Incidence","text":"","category":"section"},{"location":"man/representation/","page":"Minimal representations","title":"Minimal representations","text":"incidentvertices","category":"page"},{"location":"man/representation/#Spindles.incidentvertices","page":"Minimal representations","title":"Spindles.incidentvertices","text":"incidentvertices(p::Polytope, indices::AbstractVector{Int})\n\nList the indices of all vertices of the polytope p for which each inequality in indices is tight.\n\nIf indices is empty, this is the same as collect(1:nvertices(p)).\n\n\n\n\n\n","category":"function"},{"location":"man/representation/","page":"Minimal representations","title":"Minimal representations","text":"DocTestSetup = nothing","category":"page"},{"location":"man/plots/#Plotting-faces","page":"Plots","title":"Plotting faces","text":"","category":"section"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"To visualize 2-faces of polytopes, a Polytope object can be passed to the plot command from Plots.jl.","category":"page"},{"location":"man/plots/#Basic-usage","page":"Plots","title":"Basic usage","text":"","category":"section"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"The basic form of the plot command is","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"plot(p::Polytope, indices; kw...)","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"This creates a plot of the face of p that is defined by the inequalities in indices, provided that this face is 2-dimensional. If not, plot throws an error. To add to an existing plot, use plot!.","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"The plot can be customized using keywords in kw.... There are two types of keywords: attributes that are inherited from Plots.jl, and custom attributes defined by Spindles.jl. The following attributes are supported:","category":"page"},{"location":"man/plots/#Custom-attributes","page":"Plots","title":"Custom attributes","text":"","category":"section"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"usecoordinates: If true (default), plot a 2D projection onto a coordinate subspace. false ignores vertex coordinates and arranges the vertices on a cycle.\nvertexlabels: An indexable collection (such as AbstractVector or AbstractDict) of strings,  or nothing to disable vertex labels. If not nothing, the label of vertex i is  vertexlabels[i], where missing values are treated as \"\".  If unspecified, use vertex indices as default labels.\nineqlabels: Like vertexlabels, but for facet/inequality labels. If unspecified, use inequality indices as default labels.\nmarkup_edges: An optional tuple of edges ([s,t], [u,v]) to be marked up in the plot.  Non-parallel edges are drawn as directed edges in the following way:  If the inequality langle ax rangle le beta defines the edge [s,t],  then the other edge [u,v] is directed from u to v if and only if  langle a v-u rangle  0 (and vice versa).\nmarkup_linecolor, markup_linewidth and everything prefixed by markup_.  Note that aliases like lc or lw for the unprefixed attributes are currently not supported.","category":"page"},{"location":"man/plots/#Notable-attributes-from-Plots.jl","page":"Plots","title":"Notable attributes from Plots.jl","text":"","category":"section"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"Series attributes such as linewidth, linecolor, linealpha, ... markersize, markercolor, markeralpha, ... to customize vertex markers, fillcolor, fillalpha, ... to customize the polygon shape,\nPlot attributes such as size, ...\nSubplot attributes such as aspect_ratio, title, ...\nAxis attributes such as grid, ticks, ...","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"See also the Plots.jl documentation pages  for a list of all available attributes and their aliases. Not all of them have an effect for plotting polytopes, though.","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"note: Hardcoded attributes\nCurrently hardcoded: label attributes (font, size, colour)","category":"page"},{"location":"man/plots/#Examples","page":"Plots","title":"Examples","text":"","category":"section"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"Examples are best to demonstrate the usage of plot. Further examples can also be found in this tutorial.","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"We use the following polytope, a perturbed cube, as an example.","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"using Spindles #hide\nA = [  1   0      0\n       0   1  -1//8\n       0   0      1\n      -1   0      0\n       0  -1  -1//8\n       0   0     -1 ]\nb = [1, 9//8, 1, 1, 9//8, 1]\n\np = Polytope(A, b);\nnothing #hide","category":"page"},{"location":"man/plots/#Default-plots","page":"Plots","title":"Default plots","text":"","category":"section"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"First, let's create the simplest of all plots for one of the facets of p. (Note that all facets of p are 2-faces since p is 3-dimensional.)","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"using Plots\nplot(p, [1])","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"By default, vertices are labeled by their indices and edges by the indices of their incident facets. The 2-face itself, i.e., the facet 1, also gets a label. It is made up of the labels of its incident facets  (of which there is only one in this case, of course).","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"The axis labels indicate onto which subset of coordinates the facet was projected to obtain a planar drawing. The labels tells us that the four vertices of facet 1 were positioned at the following coordinates:","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"for i in incidentvertices(p, [1])\n    println(i, \"  \", collect(vertices(p))[i][2:3])\nend","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"Since these coordinates are difficult to check without any axis ticks, let's add them to the plot:","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"plot(p, [1]; grid=true, ticks=-2:2)","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"To ignore the geometry altogether, do","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"plot(p, [1]; usecoordinates=false)","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"Now the vertices are placed equidistantly on a cycle.","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"Pairs of edges can be marked up as follows:","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"plot(p, [1]; markup_edges = ([2,5], [7,8]))","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"The two edges passed as a tuple in markup_edges are drawn as directed edges in such a way that the arrows point away from each other. If they were parallel, such as the other two edges of facet 1, they would not have gotten arrowheads:","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"plot(p, [1]; markup_edges = ([2,7], [5,8]))","category":"page"},{"location":"man/plots/#Customization","page":"Plots","title":"Customization","text":"","category":"section"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"All plots can be customized using various attributes. In the following example, some of them are set  to override the default behaviour. Note that we use aliases like lw for linewidth, lc for linecolor, or fc for fillcolor.","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"plot(p, [1];\n    vertexlabels=nothing,             # no vertex labels\n    ineqlabels=[\"a\", \"b\", \"c\", \"d\"],  # custom edge labels\n\n    lw=5, lc=:purple,                 # appearance of edges\n    fc=:gold,                         # face colour\n    markersize=10,                    # size of vertex markers\n\n    markup_edges = ([2,5], [7,8]),    # appearance of marked up edges\n    markup_linewidth=2.5, markup_linecolor=:turquoise3,\n\n    grid=true, ticks=-2:0.5:2,        # \n    size=(350,250),                   # plot size\n    aspect_ratio=:equal,              # set unit aspect ratio\n    title=\"A fancy plot\"              # custom title\n)","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"Also note that we provided ineqlabels only for the first four facets above. Missing labels are treated as \"\".","category":"page"},{"location":"man/faces/#Faces-and-graphs","page":"Faces and graphs","title":"Faces and graphs","text":"","category":"section"},{"location":"man/faces/","page":"Faces and graphs","title":"Faces and graphs","text":"DocTestSetup = quote\n    push!(LOAD_PATH, \"../../src\")\n    using Spindles\nend","category":"page"},{"location":"man/faces/#Enumeration","page":"Faces and graphs","title":"Enumeration","text":"","category":"section"},{"location":"man/faces/","page":"Faces and graphs","title":"Faces and graphs","text":"Spindles.jl implements an algorithm for enumerating all faces of a given dimension. The algorithm  is optimized for near-simple polytopes, i.e., polytopes with few degenerate vertices. It is inspired by an algorithm for computing the graph of a polytope described here (see also the paper).","category":"page"},{"location":"man/faces/","page":"Faces and graphs","title":"Faces and graphs","text":"facesofdim","category":"page"},{"location":"man/faces/#Spindles.facesofdim","page":"Faces and graphs","title":"Spindles.facesofdim","text":"facesofdim(p::Polytope, k::Int)\n\nEnumerate all faces of dimension k of the polytope p. Each face is given by a list of the indices of its incident halfspaces.\n\nNote here that the empty face emptyset (which is the unique face of dimension −1 by convention) is given by the list of all halfspace indices, as the intersection of all facets of a polytope is empty.\n\nwarning: Difference from Polyhedra.jl\nThe index of a halfspace is the index of the corresponding inequality in the linear description of p, where (explicitly given) equality constraints (defining hyperplanes) are ignored. This is different from  the way that indices are treated in Polyhedra.jl, where hyperplanes and halfspaces share the same set of indices.\n\nnote: Note\nThe algorithm proceeds recursively and computes faces bottom-up, starting from the vertices. The results are cached internally in the Polytope object p. Therefore,  subsequent calls to facesofdim(p, l) for any l le k do not cost anything.\n\nSee also nfacesofdim, dim.\n\n\n\n\n\n","category":"function"},{"location":"man/faces/","page":"Faces and graphs","title":"Faces and graphs","text":"nfacesofdim","category":"page"},{"location":"man/faces/#Spindles.nfacesofdim","page":"Faces and graphs","title":"Spindles.nfacesofdim","text":"nfacesofdim(p::Polytope, k::Int)\n\nCount the k-dimensional faces of the polytope p.  Shorthand for length(facesofdim(p, k)).\n\nSee also nfacets, facesofdim, dim.\n\nExamples\n\njulia> V = [(i >> j) & 1 for i=0:7, j=0:2]\n8×3 Matrix{Int64}:\n 0  0  0\n 1  0  0\n 0  1  0\n 1  1  0\n 0  0  1\n 1  0  1\n 0  1  1\n 1  1  1\n\njulia> cube = Polytope(V);\n\njulia> nfacesofdim.(cube, -1:3)\n5-element Vector{Int64}:\n  1\n  8\n 12\n  6\n  1\n\n\n\n\n\n","category":"function"},{"location":"man/faces/","page":"Faces and graphs","title":"Faces and graphs","text":"For example, calling facesofdim(p, 1) lists the incident halfspaces of each edge of the polytope p. These edges, given as pairs of adjacent vertices, define the graph (or 1-skeleton) of p. The graph can also be retrieved directly:","category":"page"},{"location":"man/faces/","page":"Faces and graphs","title":"Faces and graphs","text":"graph","category":"page"},{"location":"man/faces/#Spindles.graph","page":"Faces and graphs","title":"Spindles.graph","text":"graph(p::Polytope)\n\nReturn the graph of the polytope p, which is a simple undirected graph of type  Graphs.SimpleGraphs.SimpleGraph.\n\n\n\n\n\n","category":"function"},{"location":"man/faces/#Length-of-paths","page":"Faces and graphs","title":"Length of paths","text":"","category":"section"},{"location":"man/faces/","page":"Faces and graphs","title":"Faces and graphs","text":"dist","category":"page"},{"location":"man/faces/#Spindles.dist","page":"Faces and graphs","title":"Spindles.dist","text":"dist(p::Polytope, u::Int, v::Int)\n\nCompute the distance between vertices u and v in the graph of p.\n\nExamples\n\njulia> p = Polytope([0 0; 0 1; 1 1; 1 0]);\n\njulia> vertices(p)\n4-element iterator of Vector{Rational{BigInt}}:\n Rational{BigInt}[0, 0]\n Rational{BigInt}[0, 1]\n Rational{BigInt}[1, 1]\n Rational{BigInt}[1, 0]\n\njulia> dist(p, 1, 3)\n2\n\n\n\n\n\n","category":"function"},{"location":"man/faces/#Good-faces","page":"Faces and graphs","title":"Good faces","text":"","category":"section"},{"location":"man/faces/","page":"Faces and graphs","title":"Faces and graphs","text":"Spindles.FaceState","category":"page"},{"location":"man/faces/#Spindles.FaceState","page":"Faces and graphs","title":"Spindles.FaceState","text":"FaceState\n\nFields\n\ngood::Bool\nindices: indices of all incident halfspaces\nedges\nvsets\n\n\n\n\n\n","category":"type"},{"location":"man/faces/","page":"Faces and graphs","title":"Faces and graphs","text":"isgood2face","category":"page"},{"location":"man/faces/#Spindles.isgood2face","page":"Faces and graphs","title":"Spindles.isgood2face","text":"isgood2face(p::Polytope, indices, src, dst)\n\nTest the face defined by indices for being a good 2-face of the polytope p with respect to the two vertices src and dst. Return a FaceState.\n\nSee this tutorial for an informal explanation of what it means for a 2-face to be good.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"EditURL = \"../../../examples/hirsch-i.jl\"","category":"page"},{"location":"tutorials/hirsch-i/#Spindles-and-the-Hirsch-conjecture-I","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"","category":"section"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"(Image: )","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"In this tutorial, we will explore a particular spindle that is known from theory to have an interesting property: Its apices are far away from each other in the graph of the spindle. This property made it possible to disprove a long-standing conjecture in polyhedral theory, the so-called Hirsch conjecture. Even though the focus of this tutorial is on a thorough analysis of the special spindle, we will showcase some more advanced functionalities and customization options of Spindles.jl along the way. For the basic usage, please read this tutorial first.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"note: Note\nThis tutorial is also available as a Jupyter notebook. Click on the badge above to view it in nbviewer.","category":"page"},{"location":"tutorials/hirsch-i/#The-Hirsch-conjecture","page":"Spindles and the Hirsch conjecture I","title":"The Hirsch conjecture","text":"","category":"section"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"The Hirsch conjecture for polytopes stated that any two vertices of a d-dimensional polytope with f facets can be connected by a path of at most f-d edges. It was disproved in 2010 when Francisco Santos found a construction that produces counterexamples from spindles with a special property: the length of a shortest path between the apices (called the length of the spindle) must be strictly greater than the dimension.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Santos' original counterexample from 2010 is based on a 5-dimensional spindle with 48 facets, for which the shortest path between the apices is of length 6. A minimal inequality description of this spindle (see Table 1 in Santos' paper) can be found in the file s-48-5.txt located in the examples folder beneath the package root directory Spindles.","category":"page"},{"location":"tutorials/hirsch-i/#Reading-a-spindle-from-a-file","page":"Spindles and the Hirsch conjecture I","title":"Reading a spindle from a file","text":"","category":"section"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"The data can be read from the file using the function readineq as follows.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"using Spindles\nA, b, labels = readineq(\"../../../examples/s-48-5.txt\", Int);\nnothing #hide","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"The function returns not only the coefficient matrix A and vector of right-hand sides b of the description Ax le b","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"[A b]","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"but also a label for each inequality:","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"labels","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"note: Note\nEven though we use the same set of labels as Santos in his paper, the assignment to the rows of A is different.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"The resulting spindle s has","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"s = Polytope(A, b)\nnvertices(s)","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"vertices and its apices are","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"apx = apices(s)\ncollect(vertices(s))[apx]","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"The distance between them in the graph of s is indeed 6:","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"dist(s, apx...)","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Note that both apices are highly degenerate:","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"using Graphs: degree\ndegree(graph(s), apx)","category":"page"},{"location":"tutorials/hirsch-i/#Inspecting-faces","page":"Spindles and the Hirsch conjecture I","title":"Inspecting faces","text":"","category":"section"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"The original motivation for developing Spindles.jl was the search for special two-dimensional faces (or 2-faces for short) of the spindle s and similar spindles. To explain what we mean by \"special\", let us consider the following three facets (note that all inequalities in the description given in s-48-5.txt are indeed facet-defining):","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"face = [29, 37, 41]\nlabels[face]","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"They indeed define a 2-face of s:","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"face in facesofdim(s, 2)","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"To inspect face, we may use the plot command from Plots.jl to make a plot.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"using Plots\nplot(s, face; ineqlabels=labels)","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"This creates a two-dimensional projection of face onto the two coordinates by which the axes are labeled above.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Each vertex is labeled by its index. Edges and the face itself get their labels from the incident facets, since we passed the labels extracted above to the keyword argument ineqlabels. Note here that the three facets that contain face are omitted from the edge labels.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"We may customize the above plot even further. For example, let's add more information to the vertex labels. To print the distances of each vertex to the two apices of s on a second line beneath the vertex index, we first generate all labels in the desired format. Here, we use the format \"dist1 | dist2\" for the second line of the label, where dist1 and dist2 are placeholders for the distances to apx[1] and apx[2], respectively.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"dist_labels = map(1:nvertices(s)) do v\n    \"$v\\n\" * join(dist.(s, apx, v), \" | \")\nend","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"note: Julia syntax\ndist.(s, apx, v)is a shorthand for[dist(s, a, v) for a in apx]","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Our custom vertex labels can now be passed to plot as follows:","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"plot(s, face; ineqlabels=labels, vertexlabels=dist_labels, usecoordinates=false)","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Note here that the (optional) additional argument usecoordinates=false changed the plot mode to a (combinatorial) drawing of the graph of the face 15⁺ 19⁺ 21⁺ rather than a planar projection of its true coordinates as above.","category":"page"},{"location":"tutorials/hirsch-i/#A-good-2-face","page":"Spindles and the Hirsch conjecture I","title":"A good 2-face","text":"","category":"section"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Next, let's take a closer look at our custom labels in the plot that we just generated. For each vertex of the face, the sum of both distances on the second line of its label must be at least 6, since we know that there is no shorter path between the apices. In fact, there are (at least) two such shortest paths that traverse parts of the face: One of the apices of s actually is a vertex of the face, namely the first apex","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"apx","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"at index 1. Start from there and take 3 steps to either 56 or 80. Both vertices are at distance 3 from the second apex, as their labels tell us. The only two vertices that are not visited on either of those two paths are 155 and 156, and they are also at distance 3 from the second apex.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"So among the vertices of the face 15⁺ 19⁺ 21⁺, there are two special subsets: One subset of vertices, let us call it V_1, is \"close\" to the first apex (namely, take V_1 to be the apex 1 itself). The other subset V_2 (the subset consisting of 56, 155, 156, and 80) is disjoint from the first one, and each vertex in V_2 is \"close\" to the second apex . Here, \"close\" means that if we pick two arbitrary vertices, one from each subset, then the sum of their distances to the respectively closest apex is at most some given number k. In our case, any k ge 3 would work for this definition of being \"close\", since the distance of V_1 to apx[1] is 0 and that of any vertex in V_2 to apx[2] is 3.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Let's visualize the two sets V_1 and V_2. Again, we tweak the arguments passed to plot and label the vertices of the face by which set they belong to. For example, this can be achieved by","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"set_labels = map(1:nvertices(s)) do v\n    if v == 1\n        return \"$v ∈ V₁\"\n    elseif v in [56, 155, 156, 80]\n        return \"$v ∈ V₂\"\n    else\n        return \"$v\"  # default label for vertices in neither of the two sets\n    end\nend\nplot(s, face; ineqlabels=nothing, vertexlabels=set_labels, usecoordinates=false, title=\"V₁ and V₂\")","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Note that there are exactly two edges of the face 15⁺ 19⁺ 21⁺ whose endpoints belong to neither V_1 nor V_2 (and, hence, are only labeled by their index in the plot above). These edges are those between 25 and 57, and between 33 and 81. Let's mark them up in the plot using the keyword argument markup_edges:","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"plot(s, face;\n    ineqlabels=nothing, vertexlabels=set_labels,\n    markup_edges=([25,57], [33,81]),\n    usecoordinates=false, title=\"V₁ and V₂\"\n)","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Not only are the two edges marked up in the plot, they are also drawn as directed edges now. To see why (and how this direction is determined by plot), recall that each of them is contained in a shortest path between the apices of s that walks along parts of the face 15⁺ 19⁺ 21⁺. For example, coming from the second apex (the one not contained in the face) and heading towards the first apex 1, the two highlighted edges are traversed in exactly the direction indicated above. If we look at the \"true\" geometry of 15⁺ 19⁺ 21⁺, though, we could also start from any vertex in V_2 and follow one of the two arrows (through the interior of the face!) as far as possible without leaving the face.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"plot(s, face;\n    ineqlabels=nothing, vertexlabels=set_labels,\n    markup_edges=([25,57], [33,81]),\n    usecoordinates=true, title=\"V₁ and V₂\",\n    xguide=\"\", yguide=\"\"  # hide axis labels\n)","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"The geometry of the 2-face tells us that the point on the boundary that we hit must be on one of the two edges incident to the apex 1. From that point, we walk along the edge and reach 1 within (at most) two steps on the face, rather than three steps along its boundary. So, in a relaxed regime where paths may pass through the interior of a face, one might consider taking three edges steps from the second apex to some vertex in V_2, then apply the two-step \"shortcut\" through the interior of the face 15⁺ 19⁺ 21⁺, and end up at the first apex 1. This yields (at most) 5 steps in total. Recall that in the traditional setting that forbids paths through the interior, one cannot do better than 6 steps.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"note: Note\nIt is important to note here that, unlike paths along edges, this shortcut has a direction associated to it. The direction is determined by the geometry of the 2-face 15⁺ 19⁺ 21⁺ and is indicated by the direction of the two highlighted edges. When making a plot with plot as above, they are always drawn in such a way that the arrows \"point away\" from each other.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Shortcuts like this are precisely what makes faces such as 15⁺ 19⁺ 21⁺ interesting for analyzing s in the setting of the so-called circuit diameter conjecture, a relaxation of the Hirsch conjecture that allows for paths through the interior of a polytope.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Let us call a 2-face of a spindle a good 2-face if it allows for such a shortcut between the apices as above (regardless of its direction). Spindles.jl provides a function isgood2face that tests a face for being good.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"isgood2face(s, face, apx...)","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"The result is wrapped in a bespoke data type called FaceState. The field good indicates whether or not the tested face is good, and the two vertex sets V_1 and V_2 that certify the property of being good are stored in the field vsets (see also the documentation on the FaceState type):","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"fstate = isgood2face(s, face, apx...)\nfstate.good, fstate.vsets","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Feel free to compare the output with the sets V_1 and V_2 that we identified above.","category":"page"},{"location":"tutorials/hirsch-i/#Finding-all-good-2-faces","page":"Spindles and the Hirsch conjecture I","title":"Finding all good 2-faces","text":"","category":"section"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Using the function facesofdim and isgood2face, all good 2-faces of s are easily enumerated.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"for f in sort(facesofdim(s, 2))\n    if isgood2face(s, f, apx...).good\n        println(join(labels[f], \" \"))\n    end\nend","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"In particular, for each good 2-face, there must exist paths from both apices to some vertex on the face of total length at most 3. Interestingly, all 2-faces of s that satisfy this weaker condition are good:","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"for f in sort(facesofdim(s, 2))\n    min_total_length = sum(\n        minimum(  # minimum distance of the apices to any vertex on the face\n            dist(s, a, v) for v in incidentvertices(s, f)\n        ) for a in apx\n    )\n    if min_total_length <= 3\n        println(join(labels[f], \" \"), \"\\t\", isgood2face(s, f, apx...).good)\n    end\nend","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"If you would like to explore one of the actual counterexamples to the Hirsch conjecture that was built from a spindle like s, please read on here.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"EditURL = \"../../../examples/hirsch-ii.jl\"","category":"page"},{"location":"tutorials/hirsch-ii/#Spindles-and-the-Hirsch-conjecture-II","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"","category":"section"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"(Image: )","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"In the second part of the tutorial, we will be analyzing the lowest-dimensional counterexample to the (bounded) Hirsch conjecture known to date. It is a spindle with 40 facets in dimension 20 that is constructed from a 5-dimensional \"base\" spindle found by Matschke, Santos, and Weibel. Following the terminology of part I of this tutorial, our goal is to find good 2-faces.","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"note: Note\nThis example is also available as a Jupyter notebook. Click on the badge above to view it in nbviewer.","category":"page"},{"location":"tutorials/hirsch-ii/#Good-faces-in-dimension-5","page":"Spindles and the Hirsch conjecture II","title":"Good faces in dimension 5","text":"","category":"section"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"To begin, let us enumerate the good 2-faces of the 5-dimensional spindle.","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"using Spindles\nA, b, = readineq(\"../../../examples/s-25-5.txt\", BigInt)\ns = Polytope(A, b)\napx = apices(s)","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"note: Note\nWe created s from rational data with numerators and denominators of type BigInt (this is the second argument passed to readineq). Choosing Int here (as in part I of this tutorial) would have produced an integer overflow error. See also the section on arbitrary-precision arithmetic in the Julia language documentation.","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"The following code finds all good 2-faces of s.","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"goodfaces = []\nfor f in sort(facesofdim(s, 2))\n    fstate = isgood2face(s, f, apx...)\n    if fstate.good\n        push!(goodfaces, fstate)\n    end\nend\nlength(goodfaces)","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"Next, let's plot the graph of each of those 32 good 2-faces:","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"using Plots\n\n# generate vertex labels\ndist_labels = map(1:nvertices(s)) do v\n    \"$v\\n\" * join(dist.(s, apx, v), \" | \")\nend\n\nplot_arr = []  # collect subplots to make one subplot per face in the final plot\nfor fstate in goodfaces\n    push!(plot_arr,\n        plot(s, fstate.indices; usecoordinates=false,\n            vertexlabels=dist_labels, markup_edges=fstate.edges\n        )\n    )\nend\n\nncols = 4\nnrows = ceil(Int, length(plot_arr) / ncols)  # maximum number of subplots per column\nplot(plot_arr..., layout=(nrows, ncols), size=(1000, nrows*300), plot_title=\"Good 2-faces\")","category":"page"},{"location":"tutorials/hirsch-ii/#Good-faces-in-dimension-20","page":"Spindles and the Hirsch conjecture II","title":"Good faces in dimension 20","text":"","category":"section"},{"location":"tutorials/hirsch-ii/#Patterns-in-the-inequality-description","page":"Spindles and the Hirsch conjecture II","title":"Patterns in the inequality description","text":"","category":"section"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"As a warm-up, let's take a look at the inequality description of the 20-dimensional spindle. A minimal description is provided in the file s-25.txt:","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"print(read(\"../../../examples/s-25.txt\", String))","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"You may notice that the coefficients in the first couple of columns are very similar to those of A, the coefficient matrix of the 5-dimensional \"base\" spindle s. This similarity is no coincidence: the matrix encoded in the file above is derived from A in a highly structured way. Each row has a \"counterpart\" in A. For convenience, each row above is already labeled by the index of its \"counterpart\". For example, the labels of the first three rows (the numbers in the first column) are","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"[3, 7, 2]","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"and the corresponding rows of A are","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"A[[3, 7, 2],:]","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"If you inspect those row labels closely, you may notice a pattern. Two labels appear multiple times, namely  11 and 25. The corresponding rows of A have been \"replicated\" a number of times. Each time, a new nonzero entry is added to the right whose order of magnitude is much larger than that of all other coefficients. At the polyhedral level, this \"replication\" of rows is reflected by an operation called wedging, which plays a crucial role in Santos' construction of a Hirsch counterexample from spindles like s.","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"For our purposes, the correspondence between rows of A20 and A will be extremely useful in \"guessing\" good 2-faces of the 20-dimensional spindle.","category":"page"},{"location":"tutorials/hirsch-ii/#Building-the-spindle","page":"Spindles and the Hirsch conjecture II","title":"Building the spindle","text":"","category":"section"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"Before we examine its faces, let us first read the file and construct a Spindle object from it.","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"A20, b20, labels = readineq(\"../../../examples/s-25.txt\", BigInt)\ns20 = Polytope(A20, b20)","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"To speed up computations, we tell the function apices that the system of linear inequalities specified by A20 and b20 is known to be minimal, by using the keyword argument checkredund (see also the API documentation on apices):","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"apx20 = apices(s20; checkredund=false)\ncollect(vertices(s20))[apx20]","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"Note that s20 is simple:","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"using Graphs: degree\nall(degree(graph(s20)) .== dim(s20))","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"Its most important property, however, is the length of a shortest path between the apices:","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"dist(s20, apx20...)","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"The Hirsch conjecture would imply that there must be a strictly shorter path, namely of length 20. Therefore, s20 is a counterexample to the Hirsch conjecture.","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"You may have noticed that computations in dimension 20 take longer than they did in dimension 5. Calling graph or dist for the first time on s20 (or any Spindles function that needs the graph, in fact) triggers the computation of the entire graph of s20. Luckily, we don't have to enumerate all 2-faces of s20 to identify good ones. Instead, we may take advantage of the structure in its coefficient matrix to \"guess\" good 2-faces.","category":"page"},{"location":"tutorials/hirsch-ii/#\"Guessing\"-good-2-faces","page":"Spindles and the Hirsch conjecture II","title":"\"Guessing\" good 2-faces","text":"","category":"section"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"For example, here is one of the good 2-faces of s again:","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"face = [2,8,9]\nisgood2face(s, face, apx...).good","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"To get the corresponding facets of s20, we define a function that sends a given subset of row indices of A to the corresponding rows of A20.","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"map5to20(indices) = findall(label -> label in string.(indices), labels)\nmap5to20(face)","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"Three facets don't define a 2-face in dimension 20 yet. We need another 15 facet-defining inequalities from the description of s20 (recall that s20 is simple). With some geometric intuition of what the wedging operation does, we propose the following rule of thumb: To get up to 18 facets, pick facets from those two blocks of \"replications\" labeled 11 and 25. Specifically, from each block, pick all facets but one. Let us calculate the number of facets in each block:","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"length(map5to20([11])), length(map5to20([25]))","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"So, in total, our proposed rule of thumb would indeed give us the desired number of 9+8-2=15 facets. Let us \"validate\" this rule on face. Suppose that we omit the first index in each block. Then, by our rule, we would expect the following 18 facets to define a 2-face of s20:","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"face20 = [\n    map5to20(face);\n    map5to20([11])[2:end];\n    map5to20([25])[2:end]\n]","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"Let's check whether they do, using isgood2face (which not only tests a face for being good but also checks its dimension first).","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"isgood2face(s20, face20, apx20...).good","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"Great! We have indeed found a good 2-face of s20. Let us plot this face and the original one in dimension 5 side by side.","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"plot(\n    plot(s, face; vertexlabels=nothing),\n    plot(s20, face20; vertexlabels=nothing, ineqlabels=labels),\n    layout=grid(1,2), size=(800,300)\n)","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"Not only do their projections look very similar, the two faces are also combinatorially almost identical. To see this, let us make plots of their graphs. For s20, we would like the same kind of vertex labels that we generated for the smaller spindle above:","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"dist_labels20 = Dict(map(incidentvertices(s20, face20)) do v\n    v => \"$v\\n\" * join(dist.(s20, apx20, v), \" | \")\nend)","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"Note here that we only generated labels for the vertices of face20 and stored them in a more compact dictionary rather than a (long) list of labels for all vertices of s20. For the purpose of plotting, this does not make a difference, since the function plot also accepts a dictionary of labels:","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"edges = isgood2face(s, face, apx...).edges\nedges20 = isgood2face(s20, face20, apx20...).edges\n\nplot(\n    plot(s, face; usecoordinates=false, vertexlabels=dist_labels, markup_edges=edges),\n    plot(s20, face20; usecoordinates=false, vertexlabels=dist_labels20, ineqlabels=labels, markup_edges=edges20),\n    layout=grid(1,2), size=(800,400)\n)","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"The figure on the right is the graph of the 2-face in dimension 20, with facets labeled by which facets of the 5-dimensional spindle s they correspond to. Combinatorially, the only change is an additional edge (the one defined by 4). Most importantly, however, the property of being good is preserved, since the two vertex sets V_1 and V_2 are still sufficiently close to the apices. Here, \"sufficiently close\" again means that there are paths from any pair of vertices in V_1 and V_2 to the apices apx20[1] and apx20[2], respectively, of total length 20-2=18.","category":"page"},{"location":"tutorials/hirsch-ii/#Many-good-faces","page":"Spindles and the Hirsch conjecture II","title":"Many good faces","text":"","category":"section"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"Next, let's take the analysis one step further and find such a good 2-face in dimension 20 for each of the good 2-faces of s. The following code prints one line for each good 2-face of the 5-dimensional spindle s, listing its incident facets with their indices in A and the corresponding indices in A20. The output also includes a possible choice of index pairs according to our rule of thumb above.","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"for (count, gf) in enumerate(goodfaces)\n    # loop through all pairs of indices in the two blocks corresponding to labels 11 and 25\n    for i = 1:length(map5to20([11])), j = 1:length(map5to20([25]))\n        # the face obtained after omitting i and j is:\n        f = unique([\n            map5to20(gf.indices);\n            map5to20([11])[1:end .!= i];\n            map5to20([25])[1:end .!= j]\n        ])\n\n        if isgood2face(s20, f, apx20...).good\n            println(\"good face #$(count):\\t\", gf.indices, \"\\t->   \", map5to20(gf.indices), \"\\t(except $i, $j)\")\n            break\n        end\n    end\nend","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"Notice that four good faces of s are incident to facets 11 or 25. Recall that the corresponding rows of A are precisely those that were \"replicated\" to obtain A20 from A. For those good faces, the analogous face in dimension 20 needs to be contained in all facets of the respective block of replications.","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/dimension/#Dimension","page":"Dimension","title":"Dimension","text":"","category":"section"},{"location":"man/dimension/","page":"Dimension","title":"Dimension","text":"Spindles.dim","category":"page"},{"location":"man/dimension/#Spindles.dim","page":"Dimension","title":"Spindles.dim","text":"dim(p::Polytope)\n\nCompute the dimension of p.\n\nThis is done by computing the length of a maximal chain in the face lattice of p, i.e., a finite sequence of faces \n\nemptyset = F_-1 subsetneq F_0 subsetneq F_1 subsetneq dots subsetneq F_d\n\nfor which d is maximal among all such sequences. Then F_d must be p itself, and d is its dimension.\n\nSee also Polyhedra.dim.\n\nExamples\n\njulia> p = Polytope([0 0; 1 0; 0 1; 1 1])\nPolytope{Rational{BigInt}}\n\njulia> dim(p)\n2\n\n\n\n\n\ndim(p::Polytope, indices)\ndim(p::Polytope, i::Int)\n\nCompute the dimension of the face of p that is defined by the inequalities  in the collection indices, or by the single inequality at index i. If indices is empty, this is the same as dim(p).\n\nThe implementation idea is the same as above except that the maximal face of the chain is the face defined by indices.\n\nSee also codim.\n\nExamples\n\njulia> p = Polytope([-1 0; 1 0; 0 -1; 0 1], [0, 1, 0, 1])\nPolytope{Rational{BigInt}}\n\njulia> dim(p, Int[])\n2\n\njulia> dim(p, 1)\n1\n\njulia> dim(p, [1, 3])\n0\n\njulia> dim(p, [1, 2])\n-1\n\n\n\n\n\n","category":"function"},{"location":"man/dimension/","page":"Dimension","title":"Dimension","text":"dim can be used to test whether an inequality is facet-defining  for a polytope p (see the example above). In high dimensions, this may be slow, since dim constructs a chain of faces between the empty face and the given face – which in the case of a facet amounts to a maximal chain except for the maximal face p. In this case, however, the complementary approach is fast: Find a chain of faces not between the empty face and the given face, but between the face and the polytope p itself. From the length of the resulting chain,  one can easily read off the codimension of the face (which equals 1 for a facet):","category":"page"},{"location":"man/dimension/","page":"Dimension","title":"Dimension","text":"codim","category":"page"},{"location":"man/dimension/#Spindles.codim","page":"Dimension","title":"Spindles.codim","text":"codim(p::Polytope, indices)\ncodim(p::Polytope, i::Int)\n\nCompute the codimension dim(p) - dim(p, indices) of the face of p that is defined  by the inequalities in indices, or by the single inequality at index i.\n\nFor the sake of consistency,  the codimension of the empty face of a d-dimensional polytope is defined as d+1. The implementation is complementary to dim and computes a maximal chain of faces between the given face and p itself in the face lattice of p.\n\nSee also dim.\n\nExamples\n\njulia> p = Polytope([-1 0; 1 0; 0 -1; 0 1], [0, 1, 0, 1])\nPolytope{Rational{BigInt}}\n\njulia> codim(p, Int[])\n0\n\njulia> codim(p, 1)\n1\n\njulia> codim(p, [1, 3])\n2\n\njulia> codim(p, [1, 2])\n3\n\n\n\n\n\n","category":"function"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"EditURL = \"../../../examples/firststeps.jl\"","category":"page"},{"location":"tutorials/firststeps/#First-steps","page":"First steps","title":"First steps","text":"","category":"section"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"(Image: )","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"This tutorial demonstrates the basic usage of Spindles.jl to create spindles and query basic properties.","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"note: Note\nThis tutorial is also available as a Jupyter notebook. Click on the badge above to view it in nbviewer.","category":"page"},{"location":"tutorials/firststeps/#Creating-a-spindle","page":"First steps","title":"Creating a spindle","text":"","category":"section"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"In this tutorial, we will be working with one of the simplest examples of a spindle: a cube. For example, the unit cube in 3D is given by all points x = (x_1x_2x_3) that satisfy","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"beginaligned\n-1 le x_1 le 1 \n-1 le x_2 le 1 \n-1 le x_3 le 1\nendaligned","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"In matrix notation, this is equivalent to the system Ax le b where","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"A = [1 0 0; -1 0 0; 0 1 0; 0 -1 0; 0 0 1; 0 0 -1]","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"and","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"b = [1, 1, 1, 1, 1, 1]","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"Spindles.jl provides a data type for representing and analyzing polytopes: Polytope. We may create an object of this type from our data A and b as follows:","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"using Spindles # hide\ncube = Polytope(A, b)","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"What sets a spindle apart from a general polytope is the existence of two vertices (the apices) whose incident facets partition the set of all facets. We may check cube for the existence of such a pair of vertices by running","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"apices(cube)","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"This returns the two indices of the apices as they appear in the list of all (eight) vertices of cube. To list the vertices explicitly, do","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"collect(vertices(cube))","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"note: Note\nBy default, Spindles.jl uses exact rational arithmetic. Note that the components of each vertex returned by vertices are of type Rational with numerators and denominators of type BigInt to avoid integer overflows (see the Julia documentation pages on rational numbers and arbitrary-precision arithmetic).","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"So the first and last vertex in the list above can take the role of the apices of cube. However, these two are not unique. In fact, for a cube there are many possible pairs of apices: Take an arbitrary vertex and its antipodal one, i.e., the vertex obtained by flipping the sign of each component. To prescribe an apex, pass its index as an additional argument to the function apices, which then tries to find a matching second apex:","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"apx = apices(cube, 3)","category":"page"},{"location":"tutorials/firststeps/#Working-with-the-graph","page":"First steps","title":"Working with the graph","text":"","category":"section"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"We may even compute the distance between those two apices in the graph of cube:","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"dist(cube, apx...)","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"Behind the scenes, the call to dist first computes the graph of cube. The graph can also be accessed directly using graph, which returns a graph of a type defined by the Graphs.jl package. For instance, we may verify the well-known fact that cubes are simple by using the functions dim and Graphs.degree:","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"using Graphs: degree\nall(degree(graph(cube)) .== dim(cube))","category":"page"},{"location":"tutorials/firststeps/#Counting-and-enumerating-faces","page":"First steps","title":"Counting and enumerating faces","text":"","category":"section"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"Spindles.jl also provides functions to count and enumerate the faces of cube. The following call to facesofdim returns a list of all two-dimensional faces, each one given by the indices of its incident facets.","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"note: Note\nNote here that facet indices refer to the corresponding rows of the coefficient matrix A.","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"facesofdim(cube, 2)","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"Given that the two-dimensional faces of a cube are precisely its six facets, this should not be too surprising.","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"To count the faces of a given dimension without explicitly producing a list, use the function nfacesofdim. For example, we may compute the f-vector of cube as follows.","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"nfacesofdim.(cube, 0:(dim(cube)-1))","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"This tells us that cube has 8 vertices, 12 edges, and 6 facets.","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"Next, let's list all vertices that are incident to the first facet.","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"for v in incidentvertices(cube, [1])\n    println(collect(vertices(cube))[v])\nend","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"As expected, we obtain precisely the four vertices whose first component is equal to one.","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"note: Note\nvertices returns an iterator. To access a specific element, use collect as in the code above.","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Spindles.jl","page":"Home","title":"Spindles.jl","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The goal of Spindles.jl is to provide a lightweight interface for representing and analyzing polytopes. The initial purpose of the package is to facilitate research in polyhedral theory on so-called spindles.","category":"page"},{"location":"#What-is-a-spindle?","page":"Home","title":"What is a spindle?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A spindle is a polytope with two special vertices such that each facet contains exactly one of them. These two special vertices are called the apices of the spindle. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"A simple example is a cube: For each vertex u, there is a unique vertex v that does not share a facet with u (namely, the vertex that is \"antipodal\" to u). Any such pair u and v is a valid pair of apices for the cube.","category":"page"},{"location":"#Why-are-spindles-important?","page":"Home","title":"Why are spindles important?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Spindles play an important role in the construction of counterexamples to the Hirsch conjecture. In fact, a computational analysis of these counterexamples was the main driver of the development of Spindles.jl. More details can be found in this tutorial.","category":"page"},{"location":"#Who-is-this-package-for?","page":"Home","title":"Who is this package for?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Even though the package was born out of polyhedral research on spindles,  its implementation is not specific to this special class of polytopes at all.  In fact, Spindles.jl allows for representing and analyzing any polytope.  For example, the package implements lightweight (and mostly combinatorial) algorithms to enumerate and  count faces, compute the dimension, or detect redundancy in a given linear description of a polytope.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Of course, there are many great and free software packages and libraries for manipulating polyhedra. Here is a non-exhaustive list of examples from the Julia ecosystem:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Polyhedra.jl: Implements the double description method for converting representations of polyhedra into each other. Also provides an interface to many other libraries for polyhedral computations, see the JuliaPolyhedra website.\nPolymake.jl: Julia wrapper for polymake and part of the OSCAR computer algebra system.\nCDDLib.jl: Julia wrapper for cdd.\nLRSLib.jl: Julia wrapper for lrs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The latter two are examples of libraries that can also be used with Polyhedra.jl, as can a couple of others listed on the JuliaPolyhedra website.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nSpindles.jl currently relies on Polyhedra.jl to convert a polytope given by a system of linear inequalities into a list of its vertices and vice versa.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the full API reference for more technical details on the package design and its functionalities.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Using Spindles.jl requires a working installation of Julia. Download files and detailed instructions are available on the Julia website.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To install the latest stable version of Spindles.jl, clone the parent GitHub repository by running ","category":"page"},{"location":"","page":"Home","title":"Home","text":"git clone --branch v0.3.1 https://github.com/ma-b/hirsch-walks.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"in the command line. In the Spindles subdirectory of your local clone, open the Julia REPL and enter Pkg mode by pressing ]. Then run","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> dev .","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nSee also the Pkg documentation on the dev (or develop) command.","category":"page"},{"location":"","page":"Home","title":"Home","text":"You are now ready to use Spindles.jl by typing","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Spindles","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For the basic usage of Spindles.jl, please read the tutorial on first steps.  The full documentation can be found here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To learn more about how Spindles.jl can help analyze counterexamples to the Hirsch conjecture, please check out this tutorial.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nIf you would like to run the examples presented in the tutorials yourself, you can view or  download all tutorials as Jupyter notebooks. The links can be found on the respective tutorial pages.Note that the Julia kernel for Jupyter notebooks is required to run them in your own Julia environment. It can be installed in Pkg mode by runningpkg> add IJulia\npkg> build IJulia","category":"page"}]
}
