var documenterSearchIndex = {"docs":
[{"location":"man/io/#Reading-and-writing-files","page":"Reading and writing files","title":"Reading and writing files","text":"","category":"section"},{"location":"man/io/#Spindles.writeineq","page":"Reading and writing files","title":"Spindles.writeineq","text":"writeineq(fname, A::AbstractMatrix, b::AbstractVector [, rowlabels];\n    labels=true, comments=[], comment_char='#'\n)\n\nWrite the coefficient matrix A and the vector of right-hand sides b of a system of linear inequalities to the file fname.\n\nThe file format is [rowlabels b -A] where rowlabels is a vector of strings, or just [b -A] (without a label column) if labels is false.\n\nIf no rowlabels are provided and labels is true, use the row indices as default labels.\n\nSee also readineq.\n\nKeywords\n\nlabels: If true (default), print a first column with row labels as given by the argument rowlabels. If rowlabels is unspecified, each row is labeled by its index (ranging from 1 to the number of rows of A).\ncomments: A vector of strings.  Each element in comments will be printed on its own line, following a comment_char  and a whitespace. Possible internal line breaks are ignored. The data A and b is  printed below the last line of comments.\ncomment_char: An AbstractChar that indicates the start of a comment line (default is '#').\n\nExamples\n\njulia> A = [1 0; 0 1; -1 0; 0 -1];\n\njulia> b = [1, 1, 1, 1];\n\njulia> labels = [\"α\", \"β\", \"γ\", \"δ\"];\n\njulia> writeineq(\"ineq.txt\", A, b, labels; comments=[\"A nice polytope\"])\n\njulia> print(read(\"ineq.txt\", String))\n# A nice polytope\nα  1  -1   0\nβ  1   0  -1\nγ  1   1   0\nδ  1   0   1\n\njulia> A, b, labels = readineq(\"ineq.txt\", Int);\n\njulia> A\n4×2 Matrix{Rational{Int64}}:\n  1   0\n  0   1\n -1   0\n  0  -1\n\njulia> b\n4-element Vector{Rational{Int64}}:\n 1\n 1\n 1\n 1\n\njulia> labels\n4-element Vector{String}:\n \"α\"\n \"β\"\n \"γ\"\n \"δ\"\n\njulia> rm(\"ineq.txt\")\n\n\n\n\n\n","category":"function"},{"location":"man/io/#Spindles.readineq","page":"Reading and writing files","title":"Spindles.readineq","text":"readineq(fname, T; labels=true, comment_char='#')\n\nRead A, b, labels from file fname. The element type of A and b is Rational{T}.\n\nLines starting with a comment_char character and all characters on a line following  a comment_char are ignored.\n\nSee also writeineq.\n\nKeywords\n\nlabels:\ncomment_char: \n\n\n\n\n\n","category":"function"},{"location":"man/polytopes/api/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"man/polytopes/api/","page":"Index","title":"Index","text":"Modules = [Spindles.Polytopes]","category":"page"},{"location":"man/polytopes/representations/#Representations","page":"Representations","title":"Representations","text":"","category":"section"},{"location":"man/polytopes/representations/","page":"Representations","title":"Representations","text":"We saw that a Polytope may be created from either a V- or a H-representation. Spindles.jl provides functions to retrieve both types of representations for a given polytope, and to detect redundancy.","category":"page"},{"location":"man/polytopes/representations/#Vertices","page":"Representations","title":"Vertices","text":"","category":"section"},{"location":"man/polytopes/representations/","page":"Representations","title":"Representations","text":"A polytope is the convex hull of its vertices.","category":"page"},{"location":"man/polytopes/representations/#Spindles.Polytopes.vertices","page":"Representations","title":"Spindles.Polytopes.vertices","text":"vertices(p::Polytope)\n\nReturn an iterator over the vertices of the polytope p.\n\nSee also nvertices.\n\nExamples\n\njulia> p = Polytope([    1     0\n                         0     1\n                         0     1\n                      1//2  1//2 ]);\n\njulia> collect(vertices(p))\n2-element Vector{Vector{Rational{Int64}}}:\n [1, 0]\n [0, 1]\n\n\n\n\n\n","category":"function"},{"location":"man/polytopes/representations/#Spindles.Polytopes.nvertices","page":"Representations","title":"Spindles.Polytopes.nvertices","text":"nvertices(p::Polytope)\n\nReturn the number of vertices of p.\n\nSee also vertices.\n\n\n\n\n\n","category":"function"},{"location":"man/polytopes/representations/","page":"Representations","title":"Representations","text":"The function vertices is also used to test two polytopes for equality with the == operator, see Operators.","category":"page"},{"location":"man/polytopes/representations/#Linear-systems-and-redundancy","page":"Representations","title":"Linear systems and redundancy","text":"","category":"section"},{"location":"man/polytopes/representations/","page":"Representations","title":"Representations","text":"Each vertex returned by Spindles.Polytopes.vertices is a vector in the ambient space of the polytope. The dimension of this space is given by","category":"page"},{"location":"man/polytopes/representations/#Spindles.Polytopes.ambientdim","page":"Representations","title":"Spindles.Polytopes.ambientdim","text":"ambientdim(p::Polytope)\n\nReturn the dimension of the ambient space of the polytope p.\n\nSee also dim.\n\nExamples\n\njulia> ambientdim(Polytope([[1, 0], [0, 1]]))\n2\n\n\n\n\n\n","category":"function"},{"location":"man/polytopes/representations/","page":"Representations","title":"Representations","text":"Note that this may be different from the actual dimension of a polytope (see dim) when the polytope is contained in a proper affine subspace of the ambient space. The smallest such subspace is the affine hull of the polytope. Every H-representation of a polytope must include constraints that define its affine hull. They may be included as explicit equality constraints, or as so-called implicit equations. These are inequalities that are satisfied at equality by all points in the polytope. Both types of equality constraints can be collected using affinehull.","category":"page"},{"location":"man/polytopes/representations/#Spindles.Polytopes.affinehull","page":"Representations","title":"Spindles.Polytopes.affinehull","text":"affinehull(p::Polytope; remove_rescaled=false)\n\nReturn a tuple (B, d) of a matrix B and a vector d  such that the system of linear equations Bx = d defines the affine hull of p.\n\nNote that this system is not necessarily minimal. If remove_rescaled is true,  a sufficient subsystem is returned for which no two equations are scalar multiples of one another.\n\nSee also inequalities, facets.\n\nExamples\n\nThe polytope given by\n\nbeginaligned\n0 le x_1 le 1 \nx_2 = 0\nendaligned\n\ncan be modeled by replacing the equality constraint with two inequalities pm x_2 le 0 as follows:\n\njulia> A = [-1 0; 1 0; 0 -1; 0 1]; b = [0, 1, 0, 0];\n\njulia> p = Polytope(A, b);\n\njulia> affinehull(p)\n(Rational{BigInt}[0 -1; 0 1], Rational{BigInt}[0, 0])\n\njulia> affinehull(p; remove_rescaled=true)\n(Rational{BigInt}[0 -1], Rational{BigInt}[0])\n\n\n\n\n\n","category":"function"},{"location":"man/polytopes/representations/","page":"Representations","title":"Representations","text":"To obtain a complete H-representation, we further need inequalities to describe the facets of p.","category":"page"},{"location":"man/polytopes/representations/#Spindles.Polytopes.inequalities","page":"Representations","title":"Spindles.Polytopes.inequalities","text":"inequalities(p::Polytope)\n\nReturn a tuple (A, b) of a matrix A and a vector b such that p is given by all points x in the affine hull of p that satisfy Ax le b.\n\nIf p was created from an H-representation and is full-dimensional, this will return the same system that p was created from.\n\nSee also ineqindices, facets, affinehull.\n\nExamples\n\njulia> A = [-1 0; 0 -1; 2 3]; b = [0, 0, 1];\n\njulia> inequalities(Polytope(A, b)) == (A, b)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/polytopes/representations/#Spindles.Polytopes.ineqindices","page":"Representations","title":"Spindles.Polytopes.ineqindices","text":"ineqindices(p::Polytope)\n\nReturn the valid range of indices for the rows of the coefficient matrix A returned by inequalities.\n\nSee also inequalities, Base.axes.\n\nExamples\n\njulia> ineqindices(Polytope([-1 0; 0 -1; 2 3], [0, 0, 1]))\nBase.OneTo(3)\n\n\n\n\n\n","category":"function"},{"location":"man/polytopes/representations/","page":"Representations","title":"Representations","text":"Note that the system returned by inequalities is not necessarily minimal, i.e., it may include  redundant inequalities. A redundant inequality is one whose deletion leaves the polytope unchanged. A sufficient subset of inequalities from the given description returned by inequalities can be extracted using the function facets.","category":"page"},{"location":"man/polytopes/representations/#Spindles.Polytopes.facets","page":"Representations","title":"Spindles.Polytopes.facets","text":"facets(p::Polytope)\n\nReturn a tuple (A, b) such that the system Ax le b is a minimal system of facet-definining inequalities for p.\n\nNote that this system need not be unique. If p was constructed from an H-representation for which multiple inequalities  define the same facet, the facet-defining inequality with the smallest index is selected.\n\nSee also nfacets, inequalities.\n\nExamples\n\njulia> A = [ -1   0\n              1   0\n              0  -1\n              0   1 ];\n\njulia> b = [0, 1, 0, 1];\n\njulia> p = Polytope(A, b);\n\ncreates the polytope defined by the system\n\nbeginaligned\n0 le x_1 le 1 \n0 le x_2 le 1\nendaligned\n\nwhich is minimal:\n\njulia> facets(p) == (A, b)\ntrue\n\nThe following inequalities are also valid for p:\n\nbeginaligned\n3 x_1 le 3 \nx_1 + x_2 le 2\nendaligned\n\nAdding them to the original (irredundant) system introduces redundancy:\n\njulia> q = Polytope([3 0; 1 1; A], [3; 2; b]);\n\njulia> B, d = facets(q);\n\njulia> B\n4×2 Matrix{Rational{BigInt}}:\n  3   0\n -1   0\n  0  -1\n  0   1\n\njulia> d\n4-element Vector{Rational{BigInt}}:\n 3\n 0\n 0\n 1\n\njulia> p == q == Polytope(B, d)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/polytopes/representations/#Spindles.Polytopes.nfacets","page":"Representations","title":"Spindles.Polytopes.nfacets","text":"nfacets(p::Polytope)\n\nReturn the number of facets of p.  Equivalent to nfacesofdim(p, dim(p) - 1) but has a different implementation.\n\nSee also nfacesofdim, dim, facets.\n\n\n\n\n\n","category":"function"},{"location":"man/polytopes/representations/#Incidence","page":"Representations","title":"Incidence","text":"","category":"section"},{"location":"man/polytopes/representations/#Spindles.Polytopes.incidentvertices","page":"Representations","title":"Spindles.Polytopes.incidentvertices","text":"incidentvertices(p::Polytope, indices)\n\nReturn the indices of all vertices of the polytope p for which each inequality  in the collection indices is tight (i.e., satisfied at equality).  Here, index i refers to the ith inequality in inequalities.\n\nIf indices is empty, this is the same as collect(1:nvertices(p)).\n\nSee also nvertices, inequalities, tightinequalities.\n\nExamples\n\njulia> p = Polytope([-1 0; 0 -1; 2 3], [0, 0, 1]);\n\njulia> collect(vertices(p))\n3-element Vector{Vector{Rational{BigInt}}}:\n [1//2, 0]\n [0, 1//3]\n [0, 0]\n\njulia> inequalities(p)\n(Rational{BigInt}[-1 0; 0 -1; 2 3], Rational{BigInt}[0, 0, 1])\n\njulia> incidentvertices(p, [3])\n2-element Vector{Int64}:\n 1\n 2\n\n\n\n\n\n","category":"function"},{"location":"man/polytopes/representations/#Spindles.Polytopes.tightinequalities","page":"Representations","title":"Spindles.Polytopes.tightinequalities","text":"tightinequalities(p::Polytope, indices)\n\nReturn the indices of all inequalities that are tight (i.e., satisfied at equality)  for each vertex in the collection indices.\n\nIf indices is empty, this is the same as collect(ineqindices(p)).\n\nSee also ineqindices, incidentvertices.\n\nExamples\n\njulia> p = Polytope([-1 0; 0 -1; 2 3], [0, 0, 1]);\n\njulia> collect(vertices(p))\n3-element Vector{Vector{Rational{BigInt}}}:\n [1//2, 0]\n [0, 1//3]\n [0, 0]\n\njulia> inequalities(p)\n(Rational{BigInt}[-1 0; 0 -1; 2 3], Rational{BigInt}[0, 0, 1])\n\njulia> tightinequalities(p, [1])\n2-element Vector{Int64}:\n 2\n 3\n\n\n\n\n\n","category":"function"},{"location":"man/polytopes/operators/#Operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"man/polytopes/operators/","page":"Operators","title":"Operators","text":"Spindles.jl supports common operations on polytopes.","category":"page"},{"location":"man/polytopes/operators/#Set-theoretic-operators","page":"Operators","title":"Set-theoretic operators","text":"","category":"section"},{"location":"man/polytopes/operators/#Base.:==-Tuple{Polytope, Polytope}","page":"Operators","title":"Base.:==","text":"==(p::Polytope, q::Polytope) -> Bool\n\nTest whether p and q have the same set of vertices.\n\nExamples\n\njulia> p = Polytope([1 0; 0 1]);\n\njulia> p == p\ntrue\n\njulia> p == Polytope(collect(vertices(p)))\ntrue\n\njulia> p == Polytope([1 0; 0 1; 0 1; 1//2 1//2])\ntrue\n\njulia> p == Polytope([1.0 -0.0; 0 1])\ntrue\n\njulia> p == Polytope([0.999999 0; 0 1])\nfalse\n\n\n\n\n\n","category":"method"},{"location":"man/polytopes/operators/#Base.in-Tuple{AbstractVector{<:Real}, Polytope}","page":"Operators","title":"Base.in","text":"in(x, p::Polytope) -> Bool\n∈(x, p::Polytope) -> Bool\n\nCheck whether the vector x is in the polytope p.\n\nExamples\n\njulia> p = Polytope([0 0; 1 0; 0 1]);\n\njulia> [1, 1] in p\nfalse\n\njulia> (sum(vertices(p)) / nvertices(p)) ∈ p\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/polytopes/operators/#Base.intersect-Tuple{Polytope, Vararg{Any}}","page":"Operators","title":"Base.intersect","text":"intersect(p::Polytope, polytopes...)\n∩(p::Polytope, polytopes...)\n\nIntersection of p and all polytopes in polytopes. Returns a new Polytope.\n\nSee also union.\n\nExamples\n\njulia> p = Polytope([[-1, 0], [1, 0]]) ∩ Polytope([[0, -1], [0, 1]]);\n\njulia> collect(vertices(p))\n1-element Vector{Vector{Rational{BigInt}}}:\n [0, 0]\n\njulia> p = Polytope([0 0; 1 0; 0 1]);\n\njulia> intersect((Polytope([v]) for v in vertices(p))...) |> isempty\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/polytopes/operators/#Base.isdisjoint-Tuple{Polytope, Polytope}","page":"Operators","title":"Base.isdisjoint","text":"isdisjoint(p::Polytope, q::Polytope)\n\nCheck whether p and q are disjoint. Equivalent to isempty(p ∩ q).\n\nSee also intersect, isempty.\n\nExamples\n\njulia> isdisjoint(Polytope([[-1, 0], [1, 0]]), Polytope([[0, -1], [0, 1]]))\nfalse\n\njulia> isdisjoint(Polytope([[1, 0]]), Polytope([[0, 1]]))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/polytopes/operators/#Base.isempty-Tuple{Polytope}","page":"Operators","title":"Base.isempty","text":"isempty(p::Polytope) -> Bool\n\nCheck whether p is the empty polytope emptyset.\n\nExample\n\njulia> isempty(Polytope([[1, 0], [0, 1]]))\nfalse\n\njulia> isempty(Polytope([[1, 0]]) ∩ Polytope([[0, 1]]))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/polytopes/operators/#Base.issubset-Tuple{Polytope, Polytope}","page":"Operators","title":"Base.issubset","text":"issubset(p::Polytope, q::Polytope) -> Bool\n⊆(p::Polytope, q::Polytope) -> Bool\n⊇(q::Polytope, p::Polytope) -> Bool\n\nCheck whether p is contained in q. \n\nExamples\n\njulia> p = Polytope([0 0; 1 0; 0 1]);\n\njulia> issubset(p, p)\ntrue\n\njulia> q = Polytope([0 0; 1 0; 0 1; 1 1]);\n\njulia> p ⊆ q\ntrue\n\njulia> p ⊇ q\nfalse\n\n\n\n\n\n","category":"method"},{"location":"man/polytopes/operators/#Base.union-Tuple{Polytope, Vararg{Any}}","page":"Operators","title":"Base.union","text":"union(p::Polytope, polytopes...)\n∪(p::Polytope, polytopes...)\n\nUnion of p and all polytopes in polytopes. Returns a new Polytope.\n\nSee also intersect.\n\nExamples\n\njulia> p = Polytope([[-1, 0], [1, 0]]) ∪ Polytope([[0, -1], [0, 1]]);\n\njulia> collect(vertices(p))\n4-element Vector{Vector{Rational{BigInt}}}:\n [-1, 0]\n [1, 0]\n [0, -1]\n [0, 1]\n\njulia> p == union((Polytope([v]) for v in vertices(p))...)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/polytopes/operators/#Sums-and-products-of-polytopes","page":"Operators","title":"Sums and products of polytopes","text":"","category":"section"},{"location":"man/polytopes/operators/#Base.:+-Tuple{Polytope, Polytope}","page":"Operators","title":"Base.:+","text":"+(p::Polytope, q::Polytope)\n\nMinkowski sum of polytopes p and q.\n\nExamples\n\nHypercubes are Minkowski sums of line segments:\n\njulia> p = Polytope([-1 0; 1 0]) + Polytope([0 -1; 0 1]);\n\njulia> collect(vertices(p))\n4-element Vector{Vector{Rational{BigInt}}}:\n [-1, -1]\n [-1, 1]\n [1, -1]\n [1, 1]\n\n\n\n\n\n","category":"method"},{"location":"man/polytopes/operators/#Base.sum","page":"Operators","title":"Base.sum","text":"sum(ps)\n\nMinkowski sum of the collection of Polytopes ps.\n\nExamples\n\njulia> p = sum([Polytope([[0, 0], Int.(1:2 .== i)]) for i=1:2]);\n\njulia> collect(vertices(p))\n4-element Vector{Vector{Rational{BigInt}}}:\n [0, 0]\n [0, 1]\n [1, 0]\n [1, 1]\n\n\n\n\n\n","category":"function"},{"location":"man/polytopes/operators/#Base.:*-Tuple{Polytope, Polytope}","page":"Operators","title":"Base.:*","text":"*(p::Polytope, q::Polytope)\n\nCartesian product of polytopes p and q.\n\nExamples\n\nA cube is the product of line segments:\n\njulia> p = Polytope([[0], [1]]);\n\njulia> collect(vertices(p * p * p))\n8-element Vector{Vector{Rational{BigInt}}}:\n [1, 1, 1]\n [1, 1, 0]\n [1, 0, 1]\n [1, 0, 0]\n [0, 1, 1]\n [0, 1, 0]\n [0, 0, 1]\n [0, 0, 0]\n\n\n\n\n\n","category":"method"},{"location":"man/polytopes/operators/#Transformations","page":"Operators","title":"Transformations","text":"","category":"section"},{"location":"man/polytopes/operators/#Base.:+-Tuple{Polytope, AbstractVector{<:Number}}","page":"Operators","title":"Base.:+","text":"+(t, p)\n+(p, t)\n\nTranslate the polytope p by the vector t. Returns a new Polytope.\n\nSee also -, map.\n\nExamples\n\njulia> p = Polytope([0 0; 1 0; 0 1; 1 1]);\n\njulia> collect(vertices(-[1, 1] + 2p))\n4-element Vector{Vector{Rational{BigInt}}}:\n [-1, -1]\n [1, -1]\n [-1, 1]\n [1, 1]\n\n\n\n\n\n","category":"method"},{"location":"man/polytopes/operators/#Base.:--Tuple{Polytope, AbstractVector{<:Number}}","page":"Operators","title":"Base.:-","text":"-(p, t)\n\nEquivalent to +(p, -t).\n\nSee also +.\n\nExamples\n\njulia> p = Polytope([0 0; 1 0; 0 1; 1 1]);\n\njulia> collect(vertices(2p - [1, 1]))\n4-element Vector{Vector{Rational{BigInt}}}:\n [-1, -1]\n [1, -1]\n [-1, 1]\n [1, 1]\n\n\n\n\n\n","category":"method"},{"location":"man/polytopes/operators/#Base.:*-Tuple{Polytope, Number}","page":"Operators","title":"Base.:*","text":"*(δ, p::Polytope)\n*(p::Polytope, δ)\n\nRescale p by the scalar factor δ. Returns a new Polytope.\n\nAs with standard scalar multiplication, the shorthands δp and -p (if δ == 1) also work here.\n\nSee also -, /, //, map.\n\nExamples\n\njulia> p = Polytope([[0, 0], [1, 0], [0, 1]])\nPolytope{Rational{BigInt}} in 2-space\n\njulia> collect(vertices(p * 2))\n3-element Vector{Vector{Rational{BigInt}}}:\n [0, 0]\n [2, 0]\n [0, 2]\n\njulia> 2p == p + p\ntrue\n\njulia> collect(vertices(-p))\n3-element Vector{Vector{Rational{BigInt}}}:\n [0, 0]\n [-1, 0]\n [0, -1]\n\nNote that the element type of the rescaled polytope may be different from that of p:\n\njulia> 1//2 * p\nPolytope{Rational{BigInt}} in 2-space\n\njulia> 0.5 * p\nPolytope{BigFloat} in 2-space\n\njulia> 1//2 * p == 0.5 * p\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/polytopes/operators/#Base.:/","page":"Operators","title":"Base.:/","text":"/(p::Polytope, δ)\n\nEquivalent to *(p, 1/δ).\n\nIf the scalar δ is an integer or a rational number and the element type of p  is a subtype of Integer or Rational, use // to obtain a rational polytope again.\n\nSee also //, *.\n\n\n\n\n\n","category":"function"},{"location":"man/polytopes/operators/#Base.://","page":"Operators","title":"Base.://","text":"//(p::Polytope, δ)\n\nEquivalent to *(p, 1//δ)  where both the element type of p and the type of δ must be subtypes of Integer or Rational.\n\nSee also /, *.\n\nExamples\n\njulia> p = Polytope([[0, 0], [1, 0], [0, 1//1]])\nPolytope{Rational{Int64}} in 2-space\n\njulia> p / 1\nPolytope{Float64} in 2-space\n\njulia> p // 1\nPolytope{Rational{Int64}} in 2-space\n\njulia> (p / 1) // 1\nERROR: MethodError: no method matching //(::Polytope{Float64}, ::Int64)\n[...]\n\n\n\n\n\n","category":"function"},{"location":"man/polytopes/operators/#Base.:--Tuple{Polytope}","page":"Operators","title":"Base.:-","text":"-(p::Polytope)\n\nEquivalent to *(-1, p).\n\n\n\n\n\n","category":"method"},{"location":"man/polytopes/operators/","page":"Operators","title":"Operators","text":"To define more complex mappings of the set of vertices, use map. See below for an example of how projections can be defined using map. More examples can be found in this tutorial.","category":"page"},{"location":"man/polytopes/operators/#Base.map","page":"Operators","title":"Base.map","text":"map(f, p::Polytope)\n\nReturn a new Polytope from the convex hull of the images of the vertices of p  under the function f.\n\nExamples\n\njulia> p = Polytope([0 0 0; 1 0 0; 0 2 0; 0 0 3]);\n\njulia> q = map(x -> x[1:2], p);\n\njulia> collect(vertices(q))\n3-element Vector{Vector{Rational{BigInt}}}:\n [0, 0]\n [1, 0]\n [0, 2]\n\nprojects p onto the first two coordinates.\n\njulia> q = map(x -> x .+ 1, p);\n\njulia> collect(vertices(q))\n4-element Vector{Vector{Rational{BigInt}}}:\n [1, 1, 1]\n [2, 1, 1]\n [1, 3, 1]\n [1, 1, 4]\n\ntranslates p by the all-ones vector [1, 1, 1].\n\n\n\n\n\n","category":"function"},{"location":"man/polytopes/operators/#Polarization","page":"Operators","title":"Polarization","text":"","category":"section"},{"location":"man/polytopes/operators/#Spindles.Polytopes.polarize","page":"Operators","title":"Spindles.Polytopes.polarize","text":"polarize(p::Polytope)\n\nCompute the polar dual of the polytope p.\n\nIf V denotes the set of vertices of p, then the polar dual of p is\n\n x colon v^top x le 1 text for all  v in V \n\nwhich is a polytope if and only if p contains the origin in its interior.  If this is not the case, polarize throws an error.\n\nExamples\n\nHypercubes and cross-polytopes are dual to each other:\n\njulia> cube(3) == polarize(crosspolytope(3))\ntrue\n\njulia> crosspolytope(4) == polarize(cube(4))\ntrue\n\nNote that polar duality is an involution:\n\njulia> p = cube(3);\n\njulia> p == polarize(polarize(p))\ntrue\n\nThe following polytope (a simplex) has a vertex at the origin. Therefore, polarize throws an error:\n\njulia> p = Polytope([0 0; 1 0; 0 1]);\n\njulia> polarize(p)\nERROR: got a polytope whose interior does not contain the origin\n[...]\n\nHowever, we may make the origin an interior point by taking an arbitrary interior point x of p  and shifting the polytope by -x. Here we use the centroid of p for x:\n\njulia> x = sum(vertices(p)) / nvertices(p)\n2-element Vector{Rational{BigInt}}:\n 1//3\n 1//3\n\njulia> polarize(p - x)\nPolytope{Rational{BigInt}} in 2-space\n\n\n\n\n\n","category":"function"},{"location":"man/polytopes/generators/#Generators-for-standard-polytopes","page":"Generators for standard polytopes","title":"Generators for standard polytopes","text":"","category":"section"},{"location":"man/polytopes/generators/#Spindles.Polytopes.crosspolytope-Tuple{Integer}","page":"Generators for standard polytopes","title":"Spindles.Polytopes.crosspolytope","text":"crosspolytope(n)\n\nCreate the n-dimensional standard cross-polytope  whose vertices are the 2n positive and negative standard basis vectors in mathbbR^n.\n\nExamples\n\njulia> collect(vertices(crosspolytope(3)))\n6-element Vector{Vector{Rational{BigInt}}}:\n [1, 0, 0]\n [-1, 0, 0]\n [0, 1, 0]\n [0, -1, 0]\n [0, 0, 1]\n [0, 0, -1]\n\n\n\n\n\n","category":"method"},{"location":"man/polytopes/generators/#Spindles.Polytopes.cube-Tuple{Integer}","page":"Generators for standard polytopes","title":"Spindles.Polytopes.cube","text":"cube(n)\n\nCreate the n-dimensional standard hypercube -11^n.\n\nExamples\n\njulia> collect(vertices(cube(2)))\n4-element Vector{Vector{Rational{BigInt}}}:\n [-1, -1]\n [1, -1]\n [-1, 1]\n [1, 1]\n\n\n\n\n\n","category":"method"},{"location":"man/polytopes/generators/#Spindles.Polytopes.permutahedron-Tuple{Integer}","page":"Generators for standard polytopes","title":"Spindles.Polytopes.permutahedron","text":"permutahedron(n)\n\nCreate the n-th permutahedron. It is defined as the convex hull of the vectors  (pi(1) pi(2) dots pi(n)) for all permutations pi of 12 dots n.\n\nExamples\n\njulia> p = permutahedron(3);\n\njulia> collect(vertices(p))\n6-element Vector{Vector{Rational{Int64}}}:\n [3, 2, 1]\n [3, 1, 2]\n [2, 3, 1]\n [1, 3, 2]\n [2, 1, 3]\n [1, 2, 3]\n\njulia> nvertices(p) == factorial(3)\ntrue\n\nNote that the dimension of the n-th permutahedron is n-1:\n\njulia> dim(p)\n2\n\n\n\n\n\n","category":"method"},{"location":"man/polytopes/generators/#Spindles.Polytopes.simplex-Tuple{Integer}","page":"Generators for standard polytopes","title":"Spindles.Polytopes.simplex","text":"simplex(n)\n\nCreate the n-dimensional simplex whose vertices are the standard basis vectors in mathbbR^n plus the origin.\n\nExamples\n\njulia> collect(vertices(simplex(3)))\n4-element Vector{Vector{Rational{BigInt}}}:\n [1, 0, 0]\n [0, 1, 0]\n [0, 0, 1]\n [0, 0, 0]\n\n\n\n\n\n","category":"method"},{"location":"man/polytopes/plots/#Plotting-polytopes","page":"Plotting polytopes","title":"Plotting polytopes","text":"","category":"section"},{"location":"man/polytopes/plots/","page":"Plotting polytopes","title":"Plotting polytopes","text":"Spindles.jl integrates with Plots.jl to visualize 2-dimensional polytopes (polygons) or 2-faces of higher-dimensional polytopes. ","category":"page"},{"location":"man/polytopes/plots/","page":"Plotting polytopes","title":"Plotting polytopes","text":"warning: Compatibility\nThe deprecated function plot2face has been removed as of version 0.4.","category":"page"},{"location":"man/polytopes/plots/#Basic-usage","page":"Plotting polytopes","title":"Basic usage","text":"","category":"section"},{"location":"man/polytopes/plots/","page":"Plotting polytopes","title":"Plotting polytopes","text":"A Polytope object can be passed directly to the plot command from Plots.jl as follows:","category":"page"},{"location":"man/polytopes/plots/","page":"Plotting polytopes","title":"Plotting polytopes","text":"plot(p::Polytope [, indices]; kw...)","category":"page"},{"location":"man/polytopes/plots/","page":"Plotting polytopes","title":"Plotting polytopes","text":"This creates a plot of p, or of the face of p that is defined by the inequalities  in the collection indices if specified, provided that this face (or p itself, respectively) is 2-dimensional.  If not, plot throws an error. Note that plot(p) is equivalent to plot(p, Int[]).","category":"page"},{"location":"man/polytopes/plots/","page":"Plotting polytopes","title":"Plotting polytopes","text":"To add to an existing plot, use plot!.","category":"page"},{"location":"man/polytopes/plots/","page":"Plotting polytopes","title":"Plotting polytopes","text":"The plot can be customized using keywords in kw.... The following keywords are supported:","category":"page"},{"location":"man/polytopes/plots/#1.-Plot-type-and-labels","page":"Plotting polytopes","title":"1. Plot type and labels","text":"","category":"section"},{"location":"man/polytopes/plots/","page":"Plotting polytopes","title":"Plotting polytopes","text":"usecoordinates: If true (default), plot a 2D projection onto a coordinate subspace. false ignores vertex coordinates and arranges the vertices on a cycle.\nvertexlabels: An indexable collection (such as AbstractVector or AbstractDict) of strings,  or nothing to disable vertex labels. If not nothing, the label of vertex i is  vertexlabels[i], where missing values are treated as \"\".  If unspecified, use vertex indices as default labels.\nineqlabels: Like vertexlabels, but for facet/inequality labels. If unspecified, use inequality indices as default labels.","category":"page"},{"location":"man/polytopes/plots/#2.-Attributes-from-Plots.jl","page":"Plotting polytopes","title":"2. Attributes from Plots.jl","text":"","category":"section"},{"location":"man/polytopes/plots/","page":"Plotting polytopes","title":"Plotting polytopes","text":"Can be any series, plot, subplot, or axis attributes defined by Plots.jl. See also the Plots.jl documentation on attributes and aliases. Note that not all available attributes have an effect for plotting polytopes, though. ","category":"page"},{"location":"man/polytopes/plots/","page":"Plotting polytopes","title":"Plotting polytopes","text":"Among the supported series attributes, fill attributes such as fillalpha, fillcolor, fillstyle  apply to the face itself. Line attributes such as linealpha, linecolor, linestyle, linewidth  apply to its edges and marker attributes such as markersize, markeralpha, markercolor  apply to vertex markers (see also the examples below).","category":"page"},{"location":"man/polytopes/plots/","page":"Plotting polytopes","title":"Plotting polytopes","text":"note: Hardcoded attributes\nCurrently, label attributes (font, size, colour) cannot be modified.  By default, the edge colour (linecolor) is also used for all edge labels.","category":"page"},{"location":"man/polytopes/plots/#3.-Marking-up-edges","page":"Plotting polytopes","title":"3. Marking up edges","text":"","category":"section"},{"location":"man/polytopes/plots/","page":"Plotting polytopes","title":"Plotting polytopes","text":"markup_edges: A tuple or vector of two edges s,t and u,v to be marked up in the plot.  Non-parallel edges are drawn as directed edges in the following way:  If the inequality langle ax rangle le beta defines the first edge between s and t,  then the second edge is directed from u to v if and only if  langle a v-u rangle  0 (and vice versa with the roles of the edges switched). Here, u and v refer to the actual coordinates of the respective vertices, regardless of whether usecoordinates is true or false.\nmarkup_headsize: Size of the arrowhead for directed edges.\nmarkup_headpos: A number between 0 and 1 that is taken as a relative offset of the arrow tip: 1 means that the tip is drawn at the sink (default), and 0 means it is drawn at the source of the directed edge.\nLine attributes (or aliases) prefixed by markup_ apply to the marked up edges only. For example, their width is set with markup_linewidth (or markup_lw or any other alias).","category":"page"},{"location":"man/polytopes/plots/#Examples","page":"Plotting polytopes","title":"Examples","text":"","category":"section"},{"location":"man/polytopes/plots/","page":"Plotting polytopes","title":"Plotting polytopes","text":"Examples are best to demonstrate the usage of plot. Further examples can also be found in this tutorial.","category":"page"},{"location":"man/polytopes/plots/","page":"Plotting polytopes","title":"Plotting polytopes","text":"We use the following polytope, a perturbed cube, as an example.","category":"page"},{"location":"man/polytopes/plots/","page":"Plotting polytopes","title":"Plotting polytopes","text":"using Spindles #hide\nA = [  1   0      0\n       0   1  -1//8\n       0   0      1\n      -1   0      0\n       0  -1  -1//8\n       0   0     -1 ]\nb = [1, 9//8, 1, 1, 9//8, 1]\n\np = Polytope(A, b);\nnothing #hide","category":"page"},{"location":"man/polytopes/plots/#Default-plots","page":"Plotting polytopes","title":"Default plots","text":"","category":"section"},{"location":"man/polytopes/plots/","page":"Plotting polytopes","title":"Plotting polytopes","text":"First, let's create the simplest of all plots for one of the facets of p. (Note that all facets of p are 2-faces since p is 3-dimensional.)","category":"page"},{"location":"man/polytopes/plots/","page":"Plotting polytopes","title":"Plotting polytopes","text":"using Plots\nplot(p, [1])","category":"page"},{"location":"man/polytopes/plots/","page":"Plotting polytopes","title":"Plotting polytopes","text":"By default, vertices are labeled by their indices and edges by the indices of their incident facets. The 2-face itself, i.e., the facet 1, also gets a label. It is made up of the labels of its incident facets  (of which there is only one in this case, of course).","category":"page"},{"location":"man/polytopes/plots/","page":"Plotting polytopes","title":"Plotting polytopes","text":"The axis labels indicate onto which subset of coordinates the facet was projected to obtain a planar drawing. The labels tells us that the four vertices of facet 1 were positioned at the following coordinates:","category":"page"},{"location":"man/polytopes/plots/","page":"Plotting polytopes","title":"Plotting polytopes","text":"for i in incidentvertices(p, [1])\n    println(i, \"  \", collect(vertices(p))[i][2:3])\nend","category":"page"},{"location":"man/polytopes/plots/","page":"Plotting polytopes","title":"Plotting polytopes","text":"Since these coordinates are difficult to check without any axis ticks, let's add them to the plot:","category":"page"},{"location":"man/polytopes/plots/","page":"Plotting polytopes","title":"Plotting polytopes","text":"plot(p, [1]; ticks=-2:2, minorticks=4, minorgrid=true)","category":"page"},{"location":"man/polytopes/plots/","page":"Plotting polytopes","title":"Plotting polytopes","text":"To ignore the geometry altogether, do","category":"page"},{"location":"man/polytopes/plots/","page":"Plotting polytopes","title":"Plotting polytopes","text":"plot(p, [1]; usecoordinates=false)","category":"page"},{"location":"man/polytopes/plots/","page":"Plotting polytopes","title":"Plotting polytopes","text":"Now the vertices are placed equidistantly on a cycle.","category":"page"},{"location":"man/polytopes/plots/","page":"Plotting polytopes","title":"Plotting polytopes","text":"Pairs of edges can be marked up as follows:","category":"page"},{"location":"man/polytopes/plots/","page":"Plotting polytopes","title":"Plotting polytopes","text":"plot(p, [1]; markup_edges=([2,5], [7,8]))","category":"page"},{"location":"man/polytopes/plots/","page":"Plotting polytopes","title":"Plotting polytopes","text":"The two edges passed as a tuple in markup_edges are drawn as directed edges in such a way that the arrows point away from each other. If they were parallel, such as the other two edges of facet 1, they would not have gotten arrowheads:","category":"page"},{"location":"man/polytopes/plots/","page":"Plotting polytopes","title":"Plotting polytopes","text":"plot(p, [1]; markup_edges=([2,7], [5,8]))","category":"page"},{"location":"man/polytopes/plots/#Customization","page":"Plotting polytopes","title":"Customization","text":"","category":"section"},{"location":"man/polytopes/plots/","page":"Plotting polytopes","title":"Plotting polytopes","text":"All plots can be customized using various attributes. The following example features some of them, sometimes with their full name, sometimes with aliases (such as lw for linewidth or fc for fillcolor).","category":"page"},{"location":"man/polytopes/plots/","page":"Plotting polytopes","title":"Plotting polytopes","text":"plot(p, [1];\n    vertexlabels=nothing,             # no vertex labels\n    ineqlabels=[\"a\", \"b\", \"c\", \"d\"],  # custom edge labels\n\n    lw=5, lc=:purple,                 # appearance of edges\n    fc=:gold, fillstyle=:/,           # face colour and fill pattern\n    markersize=10,                    # size of vertex markers\n\n    markup_edges=([2,5], [7,8]),      # appearance of marked up edges\n    markup_lw=2.5, markup_lc=:turquoise3,\n    markup_ls=:dash,\n    markup_headsize=42,               # size of arrowheads\n\n    grid=true, ticks=-2:0.5:2,        # coordinate axes\n    size=(350,250),                   # plot size\n    aspect_ratio=:equal,              # set unit aspect ratio\n    title=\"A fancy plot\"              # custom title\n)","category":"page"},{"location":"man/polytopes/plots/","page":"Plotting polytopes","title":"Plotting polytopes","text":"Note that we provided ineqlabels only for the first four facets above. Missing labels are treated as \"\".","category":"page"},{"location":"man/polytopes/polytopes/#Polytopes","page":"Polytopes","title":"Polytopes","text":"","category":"section"},{"location":"man/polytopes/polytopes/","page":"Polytopes","title":"Polytopes","text":"The main type defined by Spindles.jl is the type Polytope that represents a polytope. Objects of this type are constructed either from a V-representation (a list of points whose convex hull is the polytope) or from an H-representation (a system of linear inequalities whose set of solutions is the polytope):","category":"page"},{"location":"man/polytopes/polytopes/#Spindles.Polytopes.Polytope","page":"Polytopes","title":"Spindles.Polytopes.Polytope","text":"Polytope(V::AbstractVector{AbstractVector})\n\nCreate a polytope from the convex hull of the collection of points V.\n\n\n\n\n\nPolytope(V::AbstractMatrix)\n\nCreate a polytope from the convex hull of the rows of V.\n\n\n\n\n\nPolytope(A::AbstractMatrix, b::AbstractVector)\n\nCreate a polytope from its H-representation Ax le b.  If the polyhedron defined by Ax le b is unbounded, throw an error.\n\n\n\n\n\n","category":"type"},{"location":"man/polytopes/polytopes/#Examples","page":"Polytopes","title":"Examples","text":"","category":"section"},{"location":"man/polytopes/polytopes/","page":"Polytopes","title":"Polytopes","text":"julia> p = Polytope([[0, 0], [1, 0], [0, 1], [1, 1]])\nPolytope{Rational{BigInt}} in 2-space","category":"page"},{"location":"man/polytopes/polytopes/","page":"Polytopes","title":"Polytopes","text":"creates the polytope with vertices (00)(10)(01), and (11) (the two-dimensional 0/1 cube). This is the same as","category":"page"},{"location":"man/polytopes/polytopes/","page":"Polytopes","title":"Polytopes","text":"julia> q = Polytope([0 0; 1 0; 0 1; 1 1])\nPolytope{Rational{BigInt}} in 2-space\n\njulia> p == q\ntrue","category":"page"},{"location":"man/polytopes/polytopes/","page":"Polytopes","title":"Polytopes","text":"note: Note\nTwo Polytopes are considered equal by the == operator if and only if they have the same set of vertices.","category":"page"},{"location":"man/polytopes/polytopes/","page":"Polytopes","title":"Polytopes","text":"An equivalent description of the 2D polytope p is in terms of the following system of linear inequalities:","category":"page"},{"location":"man/polytopes/polytopes/","page":"Polytopes","title":"Polytopes","text":"beginaligned\n0 le x_1 le 1 \n0 le x_2 le 1\nendaligned","category":"page"},{"location":"man/polytopes/polytopes/","page":"Polytopes","title":"Polytopes","text":"This translates to","category":"page"},{"location":"man/polytopes/polytopes/","page":"Polytopes","title":"Polytopes","text":"julia> A = [ -1   0\n              1   0\n              0  -1\n              0   1 ];\n\njulia> b = [0, 1, 0, 1];\n\njulia> r = Polytope(A, b)\nPolytope{Rational{BigInt}} in 2-space\n\njulia> p == r\ntrue","category":"page"},{"location":"man/polytopes/polytopes/","page":"Polytopes","title":"Polytopes","text":"Unlike for the first two constructors above, there is no guarantee that a polyhedron defined by  a general system Ax le b is bounded (and, hence, a polytope). Indeed,  if we drop any of the four inequalities above – say the last one –, this property is lost:","category":"page"},{"location":"man/polytopes/polytopes/","page":"Polytopes","title":"Polytopes","text":"julia> Polytope(A[1:3,:], b[1:3])\nERROR: ArgumentError: got an unbounded polyhedron\n[...]","category":"page"},{"location":"man/polytopes/polytopes/","page":"Polytopes","title":"Polytopes","text":"Even though all examples so far only featured minimal descriptions of the two-dimensional 0/1 cube, a Polytope object can be created from any description of the polytope, not necessarily a minimal one. In particular, the list of points whose convex hull is the polytope can include non-vertices. Likewise, redundant inequalities and implicit equations in a system of linear inequalities are permitted.  Such redundancy can be detected, see Representations.","category":"page"},{"location":"man/polytopes/polytopes/","page":"Polytopes","title":"Polytopes","text":"note: Type parameter\nPolytope is a parametric type. Namely, the precise type of each of the three objects constructed above is Polytope{Rational{BigInt}}, where the parameter Rational{BigInt} is called the element type and is inferred from the type of the data passed to the constructor. For example, Rational{BigInt} indicates that Polytope uses exact rational arithmetic to store and manipulate the coefficients in a V- or H-representation. For integer data, this is the default choice. Suppose that we change some of the input data above to floating-point numbers, such asjulia> Polytope([-1.0 0.0; 1 0; 0 -1; 0 1], [0, 1, 0, 1])\nPolytope{Float64} in 2-spaceThen we get a different element type, namely Float64. The type of arithmetic used to represent and manipulate the Polytope object can also be set using an optional constructor argument that is borrowed from Polyhedra.jl (and that may be passed to any of the Polytope constructors):julia> using Polyhedra: DefaultLibrary\n\njulia> Polytope([-1.0 0.0; 1 0; 0 -1; 0 1], [0, 1, 0, 1], DefaultLibrary{Rational{BigInt}}())\nPolytope{Rational{BigInt}} in 2-spaceThis argument now specifies a library for polyhedral computations (the \"backend\" of Polyhedra.jl) that is to be used for the internal representation of the Polytope object. In this case, we chose the default library implemented in Polyhedra.jl but forced rational data instead of Floats.See also the JuliaPolyhedra website for a list of all supported libraries. For example, to use CDDLib with exact rational arithmetic, doimport CDDLib\nPolytope(A, b, CDDLib.Library(:exact))","category":"page"},{"location":"tutorials/permutahedra/#Line-segments,-hypercubes,-and-permutahedra","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"","category":"section"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"(Image: )","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"In the first tutorial, we worked with a cube. Cubes can be characterized and constructed in many different ways. In this tutorial, we will build them (and more complicated polytopes) from simpler polytopes, namely line segments, only using basic polyhedral operations such as Cartesian products, Minkowski sums, and translations.","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"note: Note\nThis tutorial is also available as a Jupyter notebook. Click on the badge above to view it in nbviewer.","category":"page"},{"location":"tutorials/permutahedra/#Hypercubes","page":"Line segments, hypercubes, and permutahedra","title":"Hypercubes","text":"","category":"section"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"Hypercubes are Cartesian products of line segments. For example, the 0/1 hypercube in mathbbR^n is the n-fold product of","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"using Spindles # hide\nl = Polytope([[0], [1]]);\nnothing # hide","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"which is the line segment 01 in dimension one. Spindles.jl implements the Cartesian product of two polytopes simply by overloading the multiplication operator *. Thus, the following code creates the 0/1 cube in 3D:","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"collect(vertices(l * l * l))","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"Using the Julia functions repeat and reduce, we may even create 0/1 hypercubes in any given dimension n very succinctly:","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"n = 4\np = reduce(*, repeat([l], n))\ncollect(vertices(p))","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"To make this even more convenient, Spindles.jl comes with in-built generators for common polytopes including hypercubes (see Generators for standard polytopes). The generator function cube creates a hypercube of given dimension, except that it is the standard hypercube with vertex coordinates in -11 and not the 0/1 hypercube that we created above. However, we may easily transform one into the other.","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"cube(n) == 2p - ones(n)","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"p == 1//2 * (cube(n) + ones(Int, n))","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"Note here that taking the sum of a polytope and a vector (like the all-ones vector created with ones) is interpreted as a translation of the polytope. Likewise, multiplying a polytope by a scalar rescales the entire polytope (see also Operators in the API documentation).","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"note: Operations and types\nBoth translations and rescalations of polytopes produce a new Polytope. Its element type, however, may be different from the initial one since it depends on the element type of the translation vector (or the type of the scalar multiplier, respectively).For instance, 2p - ones(n) in the first transformation above is of type Polytope{BigFloat} while p was created as a Polytope{Rational{BigInt}}. This is because ones by default creates a vector of Floats. Compare this with the second transformation above, which preserves types.","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"Consider again the line segment l from which we built our hypercube. It is also a simplex (in dimension one), which can be created using the generator function simplex:","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"simplex(1) == l","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"The code snippet above now becomes","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"p == reduce(*, repeat([simplex(1)], n))","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"Next, let's look at another class of polytopes derived from line segments (or hypercubes).","category":"page"},{"location":"tutorials/permutahedra/#Permutahedra","page":"Line segments, hypercubes, and permutahedra","title":"Permutahedra","text":"","category":"section"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"For any natural number n, the n-th permutahedron is the polytope in mathbbR^n whose vertices are precisely the n permutations of the natural numbers from 1 to n, written as vectors of length n.","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"To create a permutahedron, we could of course construct it explicitly from the list of its vertices. For the purpose of demonstration, we will follow a different approach and leverage some of the (many!) characterizations of permutahedra.","category":"page"},{"location":"tutorials/permutahedra/#Minkowski-sums","page":"Line segments, hypercubes, and permutahedra","title":"Minkowski sums","text":"","category":"section"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"Our first characterization is in terms of line segments again. In fact, take a natural number n, say","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"n = 3;\nnothing # hide","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"Then the Minkowski sum of the n(n-1)2 line segments 0 mathbfe_i - mathbfe_j for all pairs ij with 1 le i  j le n is a translate of the n-th permutahedron (where we use mathbfe_i to denote the i-th standard basis vector). To verify this computationally, let's create the directions of all those line segments first.","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"directions = [Int.(1:n .== i) - Int.(1:n .== j) for i=1:n for j=i+1:n]","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"To get the permutahedron from this collection of vectors, we create each line segment as its own Polytope, take the Minkowski sum of all segments, and finally translate the resulting polytope by the vector (12dotsn). We may do all of this in a single line using the Julia function sum:","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"p = collect(1:n) + sum(d -> Polytope([zeros(Int, n), d]), directions)\ncollect(vertices(p))","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"As desired, the vertices of the resulting polytope p are precisely the permutations of 1 to 3. Observe that the coordinates of each vertex of p sum up to 6, which implies that p cannot be full-dimensional:","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"dim(p)","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"Since the permutahedron for n=3 is 2-dimensional, we can even visualize it using Plots.jl. We label each vertex by the corresponding permutation.","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"using Plots\nplot(p; ineqlabels=nothing, vertexlabels=[join(Int.(v)) for v in vertices(p)])","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"Note that the edge directions are precisely the vectors in directions:","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"using Graphs: edges, src, dst\nfor e in edges(graph(p))\n    println(reduce(-, collect(vertices(p))[[dst(e), src(e)]]))\nend","category":"page"},{"location":"tutorials/permutahedra/#Projections-of-hypercubes","page":"Line segments, hypercubes, and permutahedra","title":"Projections of hypercubes","text":"","category":"section"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"Our second characterization of permutahedra uses hypercubes and is, in fact, closely related to the first one. Namely, suppose that we collect the directions of the line segments from which p was created in a matrix:","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"T = hcat(directions...)","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"This matrix defines a linear map, and after a translation, the image of the 0/1 hypercube under this map turns out to be our permutahedron p again.","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"m = length(directions)\nc = 1//2 * (cube(m) + ones(Int, m))  # 0/1 hypercube in dimension m\np == collect(1:n) + map(x -> T * x, c)","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"Finally, as for hypercubes, Spindles.jl also provides a convenient generator for permutahedra, called permutahedron.","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"p == permutahedron(n)","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"","category":"page"},{"location":"tutorials/permutahedra/","page":"Line segments, hypercubes, and permutahedra","title":"Line segments, hypercubes, and permutahedra","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/hirsch-i/#Spindles-and-the-Hirsch-conjecture-I","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"","category":"section"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"(Image: )","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"In this tutorial, we will explore a particular spindle that is known from theory to have an interesting property: Its apices are far away from each other in the graph of the spindle. This property made it possible to disprove a long-standing conjecture in polyhedral theory, the so-called Hirsch conjecture. Even though the focus of this tutorial is on a thorough analysis of the special spindle, we will showcase some more advanced functionalities and customization options of Spindles.jl along the way. For the basic usage, please read this tutorial first.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"note: Note\nThis tutorial is also available as a Jupyter notebook. Click on the badge above to view it in nbviewer.","category":"page"},{"location":"tutorials/hirsch-i/#The-Hirsch-conjecture","page":"Spindles and the Hirsch conjecture I","title":"The Hirsch conjecture","text":"","category":"section"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"The Hirsch conjecture for polytopes stated that any two vertices of a d-dimensional polytope with f facets can be connected by a path of at most f-d edges. It was disproved in 2010 when Francisco Santos found a construction that produces counterexamples from spindles with a special property: the length of a shortest path between the apices (called the length of the spindle) must be strictly greater than the dimension.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Santos' original counterexample from 2010 is based on a 5-dimensional spindle with 48 facets, for which the shortest path between the apices is of length 6. A minimal inequality description of this spindle (see Table 1 in Santos' paper) can be found in the file s-48-5.txt located in the examples folder beneath the package root directory Spindles.","category":"page"},{"location":"tutorials/hirsch-i/#Reading-a-spindle-from-a-file","page":"Spindles and the Hirsch conjecture I","title":"Reading a spindle from a file","text":"","category":"section"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"The data can be read from the file using the function readineq as follows.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"using Spindles\nA, b, labels = readineq(\"../../../examples/s-48-5.txt\", Int);\nnothing #hide","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"The function returns not only the coefficient matrix A and vector of right-hand sides b of the description Ax le b","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"[A b]","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"but also a label for each inequality:","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"labels","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"note: Note\nEven though we use the same set of labels as Santos in his paper, the assignment to the rows of A is different.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"The resulting spindle s has","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"s = Polytope(A, b)\nnvertices(s)","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"vertices and its apices are","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"apx = apices(s)\ncollect(vertices(s))[apx]","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"The distance between them in the graph of s is indeed 6:","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"dist(s, apx...)","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Note that both apices are highly degenerate:","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"using Graphs: degree\ndegree(graph(s), apx)","category":"page"},{"location":"tutorials/hirsch-i/#Inspecting-faces","page":"Spindles and the Hirsch conjecture I","title":"Inspecting faces","text":"","category":"section"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"The original motivation for developing Spindles.jl was the search for special two-dimensional faces (or 2-faces for short) of the spindle s and similar spindles. To explain what we mean by \"special\", let us consider the following three facets (note that all inequalities in the description given in s-48-5.txt are indeed facet-defining):","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"face = [29, 37, 41]\nlabels[face]","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"They indeed define a 2-face of s:","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"dim(s, face) == 2","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"To inspect face, we may use the plot command from Plots.jl to make a plot.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"using Plots\nplot(s, face; ineqlabels=labels)","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"This creates a two-dimensional projection of face onto the two coordinates by which the axes are labeled above.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Each vertex is labeled by its index. Edges and the face itself get their labels from the incident facets, since we passed the labels extracted above to the keyword argument ineqlabels. Note here that the three facets that contain face are omitted from the edge labels.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"We may customize the above plot even further. For example, let's add more information to the vertex labels. To print the distances of each vertex to the two apices of s on a second line beneath the vertex index, we first generate all labels in the desired format. Here, we use the format \"dist1 | dist2\" for the second line of the label, where dist1 and dist2 are placeholders for the distances to apx[1] and apx[2], respectively.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"dist_labels = map(1:nvertices(s)) do v\n    \"$v\\n\" * join(dist.(s, apx, v), \" | \")\nend","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"note: Julia syntax\ndist.(s, apx, v)is a shorthand for[dist(s, a, v) for a in apx]","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Our custom vertex labels can now be passed to plot as follows:","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"plot(s, face; ineqlabels=labels, vertexlabels=dist_labels, usecoordinates=false)","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Note here that the (optional) additional argument usecoordinates=false changed the plot mode to a (combinatorial) drawing of the graph of the face 15⁺ 19⁺ 21⁺ rather than a planar projection of its true coordinates as above.","category":"page"},{"location":"tutorials/hirsch-i/#A-good-2-face","page":"Spindles and the Hirsch conjecture I","title":"A good 2-face","text":"","category":"section"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Next, let's take a closer look at our custom labels in the plot that we just generated. For each vertex of the face, the sum of both distances on the second line of its label must be at least 6, since we know that there is no shorter path between the apices. In fact, there are (at least) two such shortest paths that traverse parts of the face: One of the apices of s actually is a vertex of the face, namely the first apex","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"apx","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"at index 1. Start from there and take 3 steps to either 56 or 80. Both vertices are at distance 3 from the second apex, as their labels tell us. The only two vertices that are not visited on either of those two paths are 155 and 156, and they are also at distance 3 from the second apex.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"So among the vertices of the face 15⁺ 19⁺ 21⁺, there are two special subsets: One subset of vertices, let us call it V_1, is \"close\" to the first apex (namely, take V_1 to be the apex 1 itself). The other subset V_2 (the subset consisting of 56, 155, 156, and 80) is disjoint from the first one, and each vertex in V_2 is \"close\" to the second apex . Here, \"close\" means that if we pick two arbitrary vertices, one from each subset, then the sum of their distances to the respectively closest apex is at most some given number k. In our case, any k ge 3 would work for this definition of being \"close\", since the distance of V_1 to apx[1] is 0 and that of any vertex in V_2 to apx[2] is 3.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Let's visualize the two sets V_1 and V_2. Again, we tweak the arguments passed to plot and label the vertices of the face by which set they belong to. For example, this can be achieved by","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"set_labels = map(1:nvertices(s)) do v\n    if v == 1\n        return \"$v ∈ V₁\"\n    elseif v in [56, 155, 156, 80]\n        return \"$v ∈ V₂\"\n    else\n        return \"$v\"  # default label for vertices in neither of the two sets\n    end\nend\nplot(s, face; ineqlabels=nothing, vertexlabels=set_labels, usecoordinates=false, title=\"V₁ and V₂\")","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Note that there are exactly two edges of the face 15⁺ 19⁺ 21⁺ whose endpoints belong to neither V_1 nor V_2 (and, hence, are only labeled by their index in the plot above). These edges are those between 25 and 57, and between 33 and 81. Let's mark them up in the plot using the keyword argument markup_edges:","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"plot(s, face;\n    ineqlabels=nothing, vertexlabels=set_labels,\n    markup_edges=([25,57], [33,81]),\n    usecoordinates=false, title=\"V₁ and V₂\"\n)","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Not only are the two edges marked up in the plot, they are also drawn as directed edges now. To see why (and how this direction is determined by plot), let's look at the true geometry of the face 15⁺ 19⁺ 21⁺ again:","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"plot(s, face;\n    ineqlabels=nothing, vertexlabels=set_labels,\n    markup_edges=([25,57], [33,81]),\n    usecoordinates=true, title=\"V₁ and V₂\",\n    xguide=\"\", yguide=\"\"  # hide axis labels\n)","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Now the two arrows point away from each other – this is precisely how the plot command decides at which endpoints to place the arrow tips.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Yet what do these directions tell us? To explain this, recall that each of the highlighted edges belongs to a shortest path (of length 6) between the apices of s. For example, we saw above that there is path of length 3 between the second apex of s (the one not contained in the face) and the vertex 156 (since 156 is in V_2). From 156, it's only 3 more edge steps to the first apex 1. Now imagine that we travel along the edges of this path towards 1, and orient each edge according to our direction of travel. Then the path becomes a sequence of steps in certain directions, where we follow each direction as far as we can – namely, until we hit the next vertex along the path.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"What happens if we choose different directions at each step? For example, suppose that we have reached 156, and now choose one of the two highlighted edge directions. To visualize the situation, we need a little extra code. First, let's define a function that, given a starting point z and a direction g, determines how far we can walk without leaving the face. In a formula, this is the maximum number mu for which A(z+mu g) le b (note that the maximum is indeed finite because the spindle s is a polytope).","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"function maxsteplength(z, g)\n    # ignore rows of A whose dot product with the given direction is <= 0\n    # since the corresponding inequalities will be satisfied for any positive step length\n    divpos(x, y) = y > 0 ? x/y : Inf\n    minimum(divpos.(b - A * z, A * g))\nend\nnothing # hide","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"With this helper function, we can now visualize what happens after a hypothetical step along either of the two arrows. In fact, we just add to the previous plot by using plot! instead of plot.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"edges = ((81,33), (57,25))  # the two edges marked up above\nsource = collect(vertices(s))[156]\n\nfor (u, v) in edges\n    edge_direction = collect(vertices(s))[v] - collect(vertices(s))[u]\n    μ = maxsteplength(source, edge_direction)\n    destination = source + μ * edge_direction\n\n    plot!(\n        # project points onto the same two coordinates (1 and 5) as the face\n        [source[1], destination[1]], [source[5], destination[5]],\n        seriestype=:arrow, linestyle=:dash, linewidth=2, linecolor=:darkorange2,\n    )\nend\ncurrent()","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"note: Plotting arrows\nThe series type arrow is a custom series type defined by Spindles.jl.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"The plot above tells us that either of the two dashed arrows (which are parallel to the marked up edges) leads us directly onto an edge that is incident with 1, rather than taking the \"detour\" along edges. In a nutshell, this is the reason why the face 15⁺ 19⁺ 21⁺ is so interesting for analyzing paths on the spindle s: It allows for a \"shortcut\" when steps through the interior of the face are allowed. Note that the choice of the vertex 156 above was arbitrary. Indeed, we could translate the tails of the two dashed arrows over to any other vertex in V_2 and still construct similar shortcuts on the face.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Let us call a 2-face of a spindle a good 2-face if it allows for such a shortcut between the apices as above (regardless of its direction). Spindles.jl provides a function isgood2face that tests a face for being good.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"isgood2face(s, face, apx...)","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"The result is wrapped in a bespoke data type called FaceState. The field good indicates whether or not the tested face is good, and the two vertex sets V_1 and V_2 that certify the property of being good are stored in the field vsets (see also the documentation on the FaceState type):","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"fstate = isgood2face(s, face, apx...)\nfstate.good, fstate.vsets","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Feel free to compare the output with the sets V_1 and V_2 that we identified above.","category":"page"},{"location":"tutorials/hirsch-i/#Finding-all-good-2-faces","page":"Spindles and the Hirsch conjecture I","title":"Finding all good 2-faces","text":"","category":"section"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Using the functions facesofdim and isgood2face, all good 2-faces of s are easily enumerated.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"for f in sort(collect(facesofdim(s, 2)))\n    if isgood2face(s, f, apx...).good\n        println(join(labels[f], \" \"))\n    end\nend","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"In particular, for each good 2-face, there must exist paths from both apices to some vertex on the face of total length at most 3. Interestingly, all 2-faces of s that satisfy this weaker condition are good:","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"for f in sort(collect(facesofdim(s, 2)))\n    min_total_length = sum(\n        minimum(  # minimum distance of the apices to any vertex on the face\n            dist(s, a, v) for v in incidentvertices(s, f)\n        ) for a in apx\n    )\n    if min_total_length <= 3\n        println(join(labels[f], \" \"), \"\\t\", isgood2face(s, f, apx...).good)\n    end\nend","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"If you would like to explore one of the actual counterexamples to the Hirsch conjecture that was built from a spindle like s, please read on here.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/hirsch-ii/#Spindles-and-the-Hirsch-conjecture-II","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"","category":"section"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"(Image: )","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"In the second part of the tutorial, we will be analyzing the lowest-dimensional counterexample to the (bounded) Hirsch conjecture known to date. It is a spindle with 40 facets in dimension 20 that is constructed from a 5-dimensional \"base\" spindle found by Matschke, Santos, and Weibel. Following the terminology of part I of this tutorial, our goal is to find good 2-faces.","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"note: Note\nThis example is also available as a Jupyter notebook. Click on the badge above to view it in nbviewer.","category":"page"},{"location":"tutorials/hirsch-ii/#Good-faces-in-dimension-5","page":"Spindles and the Hirsch conjecture II","title":"Good faces in dimension 5","text":"","category":"section"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"To begin, let us enumerate the good 2-faces of the 5-dimensional spindle.","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"using Spindles\nA, b, = readineq(\"../../../examples/s-25-5.txt\", BigInt)\ns = Polytope(A, b)\napx = apices(s)","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"note: Note\nWe created s from rational data with numerators and denominators of type BigInt (this is the second argument passed to readineq). Choosing Int here (as in part I of this tutorial) would have produced an integer overflow error. See also the section on arbitrary-precision arithmetic in the Julia language documentation.","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"The following code finds all good 2-faces of s.","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"goodfaces = []\nfor f in sort(collect(facesofdim(s, 2)))\n    fstate = isgood2face(s, f, apx...)\n    if fstate.good\n        push!(goodfaces, fstate)\n    end\nend\nlength(goodfaces)","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"Next, let's plot the graph of each of those 32 good 2-faces:","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"using Plots\n\n# generate vertex labels\ndist_labels = map(1:nvertices(s)) do v\n    \"$v\\n\" * join(dist.(s, apx, v), \" | \")\nend\n\nplot_arr = []  # collect subplots to make one subplot per face in the final plot\nfor fstate in goodfaces\n    push!(plot_arr,\n        plot(s, fstate.indices; usecoordinates=false,\n            vertexlabels=dist_labels, markup_edges=fstate.edges,\n            aspect_ratio=:equal\n        )\n    )\nend\n\nncols = 4\nnrows = ceil(Int, length(plot_arr) / ncols)  # maximum number of subplots per column\nplot(plot_arr..., layout=(nrows, ncols), size=(1000, nrows*300), plot_title=\"Good 2-faces\")","category":"page"},{"location":"tutorials/hirsch-ii/#Good-faces-in-dimension-20","page":"Spindles and the Hirsch conjecture II","title":"Good faces in dimension 20","text":"","category":"section"},{"location":"tutorials/hirsch-ii/#Patterns-in-the-inequality-description","page":"Spindles and the Hirsch conjecture II","title":"Patterns in the inequality description","text":"","category":"section"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"As a warm-up, let's take a look at the inequality description of the 20-dimensional spindle. A minimal description is provided in the file s-25.txt:","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"print(read(\"../../../examples/s-25.txt\", String))","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"You may notice that the coefficients in the first couple of columns are very similar to those of A, the coefficient matrix of the 5-dimensional \"base\" spindle s. This similarity is no coincidence: the matrix encoded in the file above is derived from A in a highly structured way. Each row has a \"counterpart\" in A. For convenience, each row above is already labeled by the index of its \"counterpart\". For example, the labels of the first three rows (the numbers in the first column) are","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"[3, 7, 2]","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"and the corresponding rows of A are","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"A[[3, 7, 2],:]","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"If you inspect those row labels closely, you may notice a pattern. Two labels appear multiple times, namely  11 and 25. The corresponding rows of A have been \"replicated\" a number of times. Each time, a new nonzero entry is added to the right whose order of magnitude is much larger than that of all other coefficients. At the polyhedral level, this \"replication\" of rows is reflected by an operation called wedging, which plays a crucial role in Santos' construction of a Hirsch counterexample from spindles like s.","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"For our purposes, the correspondence between rows of A20 and A will be extremely useful in \"guessing\" good 2-faces of the 20-dimensional spindle.","category":"page"},{"location":"tutorials/hirsch-ii/#Building-the-spindle","page":"Spindles and the Hirsch conjecture II","title":"Building the spindle","text":"","category":"section"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"Before we examine its faces, let us first read the file and construct a Polytope object from it.","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"A20, b20, labels = readineq(\"../../../examples/s-25.txt\", BigInt)\ns20 = Polytope(A20, b20)","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"To speed up computations, we tell the function apices that the system of linear inequalities specified by A20 and b20 is known to be minimal, by using the keyword argument checkredund (see also the API documentation on apices):","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"apx20 = apices(s20; checkredund=false)\ncollect(vertices(s20))[apx20]","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"Note that s20 is simple:","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"issimple(s20)","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"Its most important property, however, is the length of a shortest path between the apices:","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"dist(s20, apx20...)","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"The Hirsch conjecture would imply that there must be a strictly shorter path, namely of length 20. Therefore, s20 is a counterexample to the Hirsch conjecture.","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"You may have noticed that computations in dimension 20 take longer than they did in dimension 5. Calling graph or dist for the first time on s20 (or any other function that relies on the graph) triggers the computation of the entire graph of s20. Luckily, we don't have to enumerate all 2-faces of s20 to identify good ones. Instead, we may take advantage of the structure in its coefficient matrix to \"guess\" good 2-faces.","category":"page"},{"location":"tutorials/hirsch-ii/#\"Guessing\"-good-2-faces","page":"Spindles and the Hirsch conjecture II","title":"\"Guessing\" good 2-faces","text":"","category":"section"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"For example, here is one of the good 2-faces of s again:","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"face = [2,8,9]\nisgood2face(s, face, apx...).good","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"To get the corresponding facets of s20, we define a function that sends a given subset of row indices of A to the corresponding rows of A20.","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"map5to20(indices) = findall(label -> label in string.(indices), labels)\nmap5to20(face)","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"Three facets don't define a 2-face in dimension 20 yet. We need another 15 facet-defining inequalities from the description of s20 (recall that s20 is simple). With some geometric intuition of what the wedging operation does, we propose the following rule of thumb: To get up to 18 facets, pick facets from those two blocks of \"replications\" labeled 11 and 25. Specifically, from each block, pick all facets but one. Let us calculate the number of facets in each block:","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"length(map5to20([11])), length(map5to20([25]))","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"So, in total, our proposed rule of thumb would indeed give us the desired number of 9+8-2=15 facets. Let us \"validate\" this rule on face. Suppose that we omit the first index in each block. Then, by our rule, we would expect the following 18 facets to define a 2-face of s20:","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"face20 = [\n    map5to20(face);\n    map5to20([11])[2:end];\n    map5to20([25])[2:end]\n]","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"Let's check whether they do, using isgood2face (which not only tests a face for being good but also checks its dimension first).","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"isgood2face(s20, face20, apx20...).good","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"Great! We have indeed found a good 2-face of s20. Let us plot this face and the original one in dimension 5 side by side.","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"plot(\n    plot(s, face; vertexlabels=nothing),\n    plot(s20, face20; vertexlabels=nothing, ineqlabels=labels),\n    layout=grid(1,2), size=(800,300)\n)","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"Not only do their projections look very similar, the two faces are also combinatorially almost identical. To see this, let us make plots of their graphs. For s20, we would like the same kind of vertex labels that we generated for the smaller spindle above:","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"dist_labels20 = Dict(map(incidentvertices(s20, face20)) do v\n    v => \"$v\\n\" * join(dist.(s20, apx20, v), \" | \")\nend)","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"Note here that we only generated labels for the vertices of face20 and stored them in a more compact dictionary rather than a (long) list of labels for all vertices of s20. For the purpose of plotting, this does not make a difference, since the function plot also accepts a dictionary of labels:","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"edges = isgood2face(s, face, apx...).edges\nedges20 = isgood2face(s20, face20, apx20...).edges\n\nplot(\n    plot(s, face; usecoordinates=false,\n         vertexlabels=dist_labels,\n         markup_edges=edges, aspect_ratio=:equal),\n    plot(s20, face20; usecoordinates=false,\n         vertexlabels=dist_labels20, ineqlabels=labels,\n         markup_edges=edges20, aspect_ratio=:equal),\n    layout=grid(1,2), size=(800,400)\n)","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"The figure on the right is the graph of the 2-face in dimension 20, with facets labeled by which facets of the 5-dimensional spindle s they correspond to. Combinatorially, the only change is an additional edge (the one defined by 4). Most importantly, however, the property of being good is preserved, since the two vertex sets V_1 and V_2 are still sufficiently close to the apices. Here, \"sufficiently close\" again means that there are paths from any pair of vertices in V_1 and V_2 to the apices apx20[1] and apx20[2], respectively, of total length 20-2=18.","category":"page"},{"location":"tutorials/hirsch-ii/#Many-good-faces","page":"Spindles and the Hirsch conjecture II","title":"Many good faces","text":"","category":"section"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"Next, let's take the analysis one step further and find such a good 2-face in dimension 20 for each of the good 2-faces of s. The following code prints one line for each good 2-face of the 5-dimensional spindle s, listing its incident facets with their indices in A and the corresponding indices in A20. The output also includes a possible choice of index pairs according to our rule of thumb above.","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"for (count, gf) in enumerate(goodfaces)\n    # loop through all pairs of indices in the two blocks corresponding to labels 11 and 25\n    for i = 1:length(map5to20([11])), j = 1:length(map5to20([25]))\n        # the face obtained after omitting i and j is:\n        f = unique([\n            map5to20(gf.indices);\n            map5to20([11])[1:end .!= i];\n            map5to20([25])[1:end .!= j]\n        ])\n\n        if isgood2face(s20, f, apx20...).good\n            println(\"good face #$(count):\\t\", gf.indices, \"\\t->   \", map5to20(gf.indices), \"\\t(except $i, $j)\")\n            break\n        end\n    end\nend","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"Notice that four good faces of s are incident to facets 11 or 25. Recall that the corresponding rows of A are precisely those that were \"replicated\" to obtain A20 from A. For those good faces, the analogous face in dimension 20 needs to be contained in all facets of the respective block of replications.","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/firststeps/#First-steps","page":"First steps","title":"First steps","text":"","category":"section"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"(Image: )","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"This tutorial demonstrates the basic usage of Spindles.jl to create spindles and query basic properties.","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"note: Note\nThis tutorial is also available as a Jupyter notebook. Click on the badge above to view it in nbviewer.","category":"page"},{"location":"tutorials/firststeps/#Creating-a-spindle","page":"First steps","title":"Creating a spindle","text":"","category":"section"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"In this tutorial, we will be working with one of the simplest examples of a spindle: a cube. For example, the unit cube in 3D is given by all points x = (x_1x_2x_3) that satisfy","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"beginaligned\n-1 le x_1 le 1 \n-1 le x_2 le 1 \n-1 le x_3 le 1\nendaligned","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"In matrix notation, this is equivalent to the system Ax le b where","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"A = [1 0 0; -1 0 0; 0 1 0; 0 -1 0; 0 0 1; 0 0 -1]","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"and","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"b = [1, 1, 1, 1, 1, 1]","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"Spindles.jl provides a data type for representing and analyzing polytopes: Polytope. We may create an object of this type from our data A and b as follows:","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"using Spindles # hide\ncube = Polytope(A, b)","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"tip: Tip\nThe 3D unit cube can also be created using the generator function cube implemented in Spindles.jl.","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"What sets a spindle apart from a general polytope is the existence of two vertices (the apices) whose incident facets partition the set of all facets. We may check cube for the existence of such a pair of vertices by running","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"apices(cube)","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"This returns the two indices of the apices as they appear in the list of all (eight) vertices of cube. To list the vertices explicitly, do","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"collect(vertices(cube))","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"note: Note\nBy default, Spindles.jl uses exact rational arithmetic. Note that the components of each vertex returned by vertices are of type Rational with numerators and denominators of type BigInt to avoid integer overflows (see the Julia documentation pages on rational numbers and arbitrary-precision arithmetic).","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"So the first and last vertex in the list above can take the role of the apices of cube. However, these two are not unique. In fact, for a cube there are many possible pairs of apices: Take an arbitrary vertex and its antipodal one, i.e., the vertex obtained by flipping the sign of each component. To prescribe an apex, pass its index as an additional argument to the function apices, which then tries to find a matching second apex:","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"apx = apices(cube, 3)","category":"page"},{"location":"tutorials/firststeps/#Working-with-the-graph","page":"First steps","title":"Working with the graph","text":"","category":"section"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"We may even compute the distance between those two apices in the graph of cube:","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"dist(cube, apx...)","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"Behind the scenes, the call to dist first computes the graph of cube. The graph can also be accessed directly using graph, which returns a graph of a type defined by the Graphs.jl package. For instance, we may verify the well-known fact that cubes are simple by using the functions dim and Graphs.degree:","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"using Graphs: degree\nall(degree(graph(cube)) .== dim(cube))","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"To make verifying this property more convenient, Spindles.jl provides the function issimple that checks a polytope for being simple:","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"issimple(cube)","category":"page"},{"location":"tutorials/firststeps/#Counting-and-enumerating-faces","page":"First steps","title":"Counting and enumerating faces","text":"","category":"section"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"Spindles.jl also provides functions to count and enumerate the faces of cube. The following call to facesofdim returns all two-dimensional faces, each one given by the indices of its incident facets.","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"note: Note\nNote here that facet indices refer to the corresponding rows of the coefficient matrix A.","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"collect(facesofdim(cube, 2))","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"Given that the two-dimensional faces of a cube are precisely its six facets, this should not be too surprising.","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"To count the faces of a given dimension without explicitly producing a list, use the function nfacesofdim. For example, we may compute the f-vector of cube as follows.","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"nfacesofdim.(cube, 0:(dim(cube)-1))","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"This tells us that cube has 8 vertices, 12 edges, and 6 facets.","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"Next, let's list all vertices that are incident to the first facet.","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"for v in incidentvertices(cube, [1])\n    println(collect(vertices(cube))[v])\nend","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"As expected, we obtain precisely the four vertices whose first component is equal to one.","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"note: Note\nvertices, like facesofdim, returns an iterator. To access a specific element, use collect as in the code above.","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/goodfaces/#Good-2-faces","page":"Good 2-faces","title":"Good 2-faces","text":"","category":"section"},{"location":"man/goodfaces/#Spindles.FaceState","page":"Good 2-faces","title":"Spindles.FaceState","text":"FaceState\n\nFields\n\ngood::Bool\nindices: indices of all tight inequalities for the face\nedges\nvsets\n\n\n\n\n\n","category":"type"},{"location":"man/goodfaces/#Spindles.isgood2face","page":"Good 2-faces","title":"Spindles.isgood2face","text":"isgood2face(p::Polytope, indices, src, dst)\n\nTest the face defined by indices for being a good 2-face of the polytope p with respect to the two vertices src and dst. Return a FaceState.\n\nSee this tutorial for an informal explanation of what it means for a 2-face to be good.\n\n\n\n\n\n","category":"function"},{"location":"#Spindles.jl","page":"Home","title":"Spindles.jl","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The goal of Spindles.jl is to provide a lightweight interface for representing and analyzing polytopes. The initial purpose of the package is to facilitate research in polyhedral theory on so-called spindles.","category":"page"},{"location":"#What-is-a-spindle?","page":"Home","title":"What is a spindle?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A spindle is a polytope with two special vertices such that each facet contains exactly one of them. These two special vertices are called the apices of the spindle. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"A simple example is a cube: For each vertex u, there is a unique vertex v that does not share a facet with u (namely, the vertex that is \"antipodal\" to u). Any such pair u and v is a valid pair of apices for the cube.","category":"page"},{"location":"#Why-are-spindles-important?","page":"Home","title":"Why are spindles important?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Spindles play an important role in the construction of counterexamples to the Hirsch conjecture. In fact, a computational analysis of these counterexamples was the main driver of the development of Spindles.jl. More details can be found in this tutorial.","category":"page"},{"location":"#Who-is-this-package-for?","page":"Home","title":"Who is this package for?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Even though the package was born out of polyhedral research on spindles,  its implementation is not specific to this special class of polytopes at all.  In fact, Spindles.jl allows for representing and analyzing any polytope.  For example, the package implements lightweight (and mostly combinatorial) algorithms to enumerate and  count faces, compute the dimension, or detect redundancy in a given linear description of a polytope.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Of course, there are many great and free software packages and libraries for manipulating polyhedra. Here is a non-exhaustive list of examples from the Julia ecosystem:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Polyhedra.jl: Implements the double description method for converting representations of polyhedra into each other. Also provides an interface to many other libraries for polyhedral computations, see the JuliaPolyhedra website.\nPolymake.jl: Julia wrapper for polymake and part of the OSCAR computer algebra system.\nCDDLib.jl: Julia wrapper for cdd.\nLRSLib.jl: Julia wrapper for lrs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The latter two are examples of libraries that can also be used with Polyhedra.jl, as can a couple of others listed on the JuliaPolyhedra website.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nSpindles.jl currently relies on Polyhedra.jl to convert a polytope given by a system of linear inequalities into a list of its vertices and vice versa.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the full API reference for more technical details on the package design and its functionalities.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Using Spindles.jl requires a working installation of Julia. Download files and detailed instructions are available on the Julia website.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To install the latest stable version of Spindles.jl, clone the parent GitHub repository by running ","category":"page"},{"location":"","page":"Home","title":"Home","text":"git clone --branch v0.4.1 https://github.com/ma-b/hirsch-walks.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"in the command line. In the Spindles subdirectory of your local clone, open the Julia REPL and enter Pkg mode by pressing ]. Then run","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> dev .","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nSee also the Pkg documentation on the dev (or develop) command.","category":"page"},{"location":"","page":"Home","title":"Home","text":"You are now ready to use Spindles.jl by typing","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Spindles","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For the basic usage of Spindles.jl, please read the tutorial on first steps.  The full documentation can be found here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To learn more about how Spindles.jl can help analyze counterexamples to the Hirsch conjecture, please check out this tutorial.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nIf you would like to run the examples presented in the tutorials yourself, you can view or  download all tutorials as Jupyter notebooks. The links can be found on the respective tutorial pages.Note that the Julia kernel for Jupyter notebooks is required to run them in your own Julia environment. It can be installed in Pkg mode by runningpkg> add IJulia\npkg> build IJulia","category":"page"},{"location":"man/polytopes/combinatorics/#Combinatorics","page":"Combinatorics","title":"Combinatorics","text":"","category":"section"},{"location":"man/polytopes/combinatorics/#Dimension","page":"Combinatorics","title":"Dimension","text":"","category":"section"},{"location":"man/polytopes/combinatorics/#Spindles.Polytopes.dim","page":"Combinatorics","title":"Spindles.Polytopes.dim","text":"dim(p::Polytope)\n\nCompute the dimension of p.\n\nThis is done by computing the length of a maximal chain in the face lattice of p, i.e., a finite sequence of faces \n\nemptyset = F_-1 subsetneq F_0 subsetneq F_1 subsetneq dots subsetneq F_d\n\nfor which d is maximal among all such sequences. Then F_d must be p itself, and d is its dimension.\n\nSee also ambientdim,  Polyhedra.dim.\n\nExamples\n\njulia> p = Polytope([0 0; 1 0; 0 1; 1 1]);\n\njulia> dim(p)\n2\n\n\n\n\n\ndim(p::Polytope, indices)\ndim(p::Polytope, i::Int)\n\nCompute the dimension of the face of p that is defined by the inequalities  in the collection indices, or by the single inequality at index i. If indices is empty, this is the same as dim(p).\n\nThe implementation idea is the same as above except that the maximal face of the chain is the face defined by indices.\n\nSee also codim.\n\nExamples\n\njulia> p = Polytope([-1 0; 1 0; 0 -1; 0 1], [0, 1, 0, 1]);\n\njulia> dim(p, Int[])\n2\n\njulia> dim(p, 1)\n1\n\njulia> dim(p, [1, 3])\n0\n\njulia> dim(p, [1, 2])\n-1\n\n\n\n\n\n","category":"function"},{"location":"man/polytopes/combinatorics/","page":"Combinatorics","title":"Combinatorics","text":"dim can be used to test whether an inequality is facet-defining  for a polytope p (see the example above). In high dimensions, this may be slow, since dim constructs a chain of faces between the empty face and the given face – which in the case of a facet amounts to a maximal chain except for the maximal face p. In this case, however, the complementary approach is fast: Find a chain of faces not between the empty face and the given face, but between the face and the polytope p itself. From the length of the resulting chain,  one can easily read off the codimension of the face (which equals 1 for a facet):","category":"page"},{"location":"man/polytopes/combinatorics/#Spindles.Polytopes.codim","page":"Combinatorics","title":"Spindles.Polytopes.codim","text":"codim(p::Polytope, indices)\ncodim(p::Polytope, i::Int)\n\nCompute the codimension dim(p) - dim(p, indices) of the face of p that is defined  by the inequalities in indices, or by the single inequality at index i.\n\nFor the sake of consistency,  the codimension of the empty face of a d-dimensional polytope is defined as d+1. The implementation is complementary to dim and computes a maximal chain of faces between the given face and p itself in the face lattice of p.\n\nSee also dim.\n\nExamples\n\njulia> p = Polytope([-1 0; 1 0; 0 -1; 0 1], [0, 1, 0, 1]);\n\njulia> codim(p, Int[])\n0\n\njulia> codim(p, 1)\n1\n\njulia> codim(p, [1, 3])\n2\n\njulia> codim(p, [1, 2])\n3\n\n\n\n\n\n","category":"function"},{"location":"man/polytopes/combinatorics/#Face-enumeration","page":"Combinatorics","title":"Face enumeration","text":"","category":"section"},{"location":"man/polytopes/combinatorics/","page":"Combinatorics","title":"Combinatorics","text":"Spindles.jl implements an algorithm for enumerating all faces of a given dimension. The algorithm  is optimized for near-simple polytopes, i.e., polytopes with few degenerate vertices. It is inspired by an algorithm for computing the graph of a polytope described here (see also the paper).","category":"page"},{"location":"man/polytopes/combinatorics/#Spindles.Polytopes.facesofdim","page":"Combinatorics","title":"Spindles.Polytopes.facesofdim","text":"facesofdim(p::Polytope, k::Int)\n\nReturn (an iterator over or a collection of) all faces of dimension k of the polytope p. Each face is given by a list of  the indices of all tight inequalities.\n\nNote here that the empty face emptyset (which is the unique face of dimension −1 by convention) is given by the list of all inequality indices, as the intersection of all facets of a polytope is empty.\n\nnote: Implementation note\nThe algorithm proceeds recursively and computes faces bottom-up, starting from the vertices. The results are cached internally in the Polytope object p. Therefore,  subsequent calls to facesofdim(p, l) for any l le k do not cost anything.\n\nSee also nfacesofdim, dim.\n\n\n\n\n\n","category":"function"},{"location":"man/polytopes/combinatorics/#Spindles.Polytopes.nfacesofdim","page":"Combinatorics","title":"Spindles.Polytopes.nfacesofdim","text":"nfacesofdim(p::Polytope, k::Int)\n\nCount the k-dimensional faces of the polytope p.  Shorthand for length(facesofdim(p, k)).\n\nSee also nfacets, facesofdim, dim.\n\nExamples\n\njulia> nfacesofdim.(cube(3), -1:3)\n5-element Vector{Int64}:\n  1\n  8\n 12\n  6\n  1\n\n\n\n\n\n","category":"function"},{"location":"man/polytopes/combinatorics/#Graphs-and-distances","page":"Combinatorics","title":"Graphs and distances","text":"","category":"section"},{"location":"man/polytopes/combinatorics/","page":"Combinatorics","title":"Combinatorics","text":"For example, calling facesofdim(p, 1) lists the one-dimensional faces, the edges, of the polytope p. These edges, written as pairs of adjacent vertices, define the graph (or 1-skeleton) of p. The graph can also be retrieved directly:","category":"page"},{"location":"man/polytopes/combinatorics/#Spindles.Polytopes.graph","page":"Combinatorics","title":"Spindles.Polytopes.graph","text":"graph(p::Polytope)\n\nReturn the graph of the polytope p, which is a simple undirected graph of type  Graphs.SimpleGraphs.SimpleGraph.\n\n\n\n\n\n","category":"function"},{"location":"man/polytopes/combinatorics/#Spindles.Polytopes.dist","page":"Combinatorics","title":"Spindles.Polytopes.dist","text":"dist(p::Polytope, u::Int, v::Int)\n\nCompute the distance between vertices u and v in the graph of p.\n\nExamples\n\njulia> p = Polytope([0 0; 0 1; 1 1; 1 0]);\n\njulia> collect(vertices(p))\n4-element Vector{Vector{Rational{BigInt}}}:\n [0, 0]\n [0, 1]\n [1, 1]\n [1, 0]\n\njulia> dist(p, 1, 3)\n2\n\n\n\n\n\n","category":"function"},{"location":"man/polytopes/combinatorics/#Simplicity-and-simpliciality","page":"Combinatorics","title":"Simplicity and simpliciality","text":"","category":"section"},{"location":"man/polytopes/combinatorics/#Spindles.Polytopes.issimple","page":"Combinatorics","title":"Spindles.Polytopes.issimple","text":"issimple(p::Polytope) -> Bool\n\nDetermine whether p is simple, i.e., whether each vertex of p is contained in exactly dim(p) facets.\n\nSee also dim, issimplicial.\n\nExamples\n\njulia> issimple(simplex(3))\ntrue\n\njulia> issimple(cube(3))\ntrue\n\njulia> issimple(crosspolytope(3))\nfalse\n\n\n\n\n\n","category":"function"},{"location":"man/polytopes/combinatorics/#Spindles.Polytopes.issimplicial","page":"Combinatorics","title":"Spindles.Polytopes.issimplicial","text":"issimplicial(p::Polytope) -> Bool\n\nDetermine whether p is simplicial, i.e., whether each facet of p is a simplex.\n\nSee also issimple.\n\nExamples\n\njulia> issimplicial(simplex(3))\ntrue\n\njulia> issimplicial(cube(3))\nfalse\n\njulia> issimplicial(crosspolytope(3))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/polytopes/combinatorics/#Spindles","page":"Combinatorics","title":"Spindles","text":"","category":"section"},{"location":"man/polytopes/combinatorics/","page":"Combinatorics","title":"Combinatorics","text":"Spindles are special polytopes for which each facet is incident to exactly one of two special vertices.","category":"page"},{"location":"man/polytopes/combinatorics/#Spindles.Polytopes.apices","page":"Combinatorics","title":"Spindles.Polytopes.apices","text":"apices(p::Polytope [, apex::Int]; checkredund=true)\n\nCheck whether p is a spindle, i.e., whether there is a pair of vertices (the apices) for which each facet of p is incident to exactly one of them. If p has a pair of apices, return their indices; otherwise return nothing.\n\nThe optional argument apex specifies the index of a vertex that is to be taken as one of the apices.\n\nKeywords\n\ncheckredund::Bool: If true (default), first detect all inequalities in the description of p    that are not facet-defining for p.    If p was created from an inequality description that is known to be minimal, this step may be skipped   by setting checkredund to false.\n\nnote: Note\nIn the presence of redundant inequalities, disabling checkredund can only produce false negatives:  Whenever apices returns a pair of vertices, they are guaranteed to be apices of p. The converse, however, is not necessarily true. A spindle may not be detected as such if its inequality description contains inequalities that are not facet-defining.\n\nExamples\n\njulia> p = Polytope([1 0; 0 1; -1 0; 0 -1], [1, 1, 1, 1]);\n\njulia> collect(vertices(p))\n4-element Vector{Vector{Rational{BigInt}}}:\n [-1, -1]\n [1, -1]\n [-1, 1]\n [1, 1]\n\njulia> apices(p)\n2-element Vector{Int64}:\n 1\n 4\n\njulia> apices(p, 2)\n2-element Vector{Int64}:\n 2\n 3\n\n\n\n\n\n","category":"function"}]
}
