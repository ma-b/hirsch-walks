var documenterSearchIndex = {"docs":
[{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"EditURL = \"../../../examples/hirsch-ii.jl\"","category":"page"},{"location":"tutorials/hirsch-ii/#Spindles-and-the-Hirsch-conjecture-II","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"","category":"section"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"(Image: )","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"In the second part of the tutorial, we will be analyzing the lowest-dimensional counterexample to the (bounded) Hirsch conjecture known to date. It is a spindle with 40 facets in dimension 20 that is constructed from a 5-dimensional \"base\" spindle found by Matschke, Santos, and Weibel. Following the terminology of part I of this tutorial, our goal is to find good 2-faces.","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"note: Note\nThis example is also available as a Jupyter notebook. Click on the badge above to view it in nbviewer.","category":"page"},{"location":"tutorials/hirsch-ii/#Dimension-5","page":"Spindles and the Hirsch conjecture II","title":"Dimension 5","text":"","category":"section"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"To begin, let us enumerate the good 2-faces of the 5-dimensional spindle.","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"using Spindles\nA, b, = readineq(\"../../../examples/s-25-5.txt\", BigInt)\ns = Polytope(A, b)\napx = apices(s)","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"note: Note\nWe created s from rational data with numerators and denominators of type BigInt (this is the second argument passed to readineq). Choosing Int here (as in part I of this tutorial) would have produced an integer overflow error. See also the section on arbitrary-precision arithmetic in the Julia language documentation.","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"The following code finds all good 2-faces of s.","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"goodfaces = []\nfor f in sort(facesofdim(s, 2))\n    fstate = isgood2face(s, f, apx...)\n    if fstate.good\n        push!(goodfaces, fstate)\n    end\nend\nlength(goodfaces)","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"Next, let's plot the graph of each of those 32 good 2-faces:","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"using Plots\n\ndist_labels = map(1:nvertices(s)) do v\n    \"$v\\n\" * join(dist.(s, apx, v), \" | \")\nend\n\nplot_arr = []\nfor fstate in goodfaces\n    push!(plot_arr,\n        plot2face(s, fstate.facets;\n            vertexlabels=dist_labels, usecoordinates=false, directed_edges=fstate.edges\n        )\n    )\nend\n\nncols = 4\nnrows = ceil(Int, length(plot_arr) / ncols)\nplot(plot_arr..., layout=(nrows, ncols), size=(1000, nrows*300), plot_title=\"Good 2-faces\")\nsavefig(\"s-25-5-all.svg\"); nothing # hide","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"(Image: )","category":"page"},{"location":"tutorials/hirsch-ii/#Dimension-20","page":"Spindles and the Hirsch conjecture II","title":"Dimension 20","text":"","category":"section"},{"location":"tutorials/hirsch-ii/#Warm-up:-Patterns-in-the-inequality-description","page":"Spindles and the Hirsch conjecture II","title":"Warm-up: Patterns in the inequality description","text":"","category":"section"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"Let us first take a look at the inequality description of the 20-dimensional spindle. A minimal description is provided in the file s-25.txt. Its contents are as follows:","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"print(read(\"../../../examples/s-25.txt\", String))","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"You may notice that the coefficients in the first couple of columns are very similar to those of A, the coefficient matrix of the 5-dimensional \"base\" spindle s. This similarity is no coincidence: the matrix encoded in the file above is derived from A in a highly structured way. Each row has a \"counterpart\" in A. For convenience, each row above is already labeled by the index of its \"counterpart\". For example, the labels of the first three rows (the numbers in the first column) are","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"[3, 7, 2]","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"and the corresponding rows of A are","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"A[[3, 7, 2],:]","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"If you inspect those row labels closely, you may notice a pattern. Two labels appear multiple times, namely  11 and 25. The corresponding rows of A have been \"replicated\" a number of times. Each time, a new nonzero entry is added to the right whose order of magnitude is much larger than that of all other coefficients. At the polyhedral level, this \"replication\" of rows is reflected by an operation called wedging, which plays a crucial role in Santos' construction of a Hirsch counterexample from spindles like s.","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"The structure that we just observed will be extremely useful in \"guessing\" good 2-faces of the 20-dimensional spindle encoded in the file above. Before we examine its faces, let us first read the file and construct a Spindle object from it.","category":"page"},{"location":"tutorials/hirsch-ii/#Building-the-spindle","page":"Spindles and the Hirsch conjecture II","title":"Building the spindle","text":"","category":"section"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"A20, b20, labels = readineq(\"../../../examples/s-25.txt\", BigInt)\ns20 = Polytope(A20, b20)\n\napx20 = apices(s20)\ncollect(vertices(s20))[apx20]","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"","category":"page"},{"location":"tutorials/hirsch-ii/","page":"Spindles and the Hirsch conjecture II","title":"Spindles and the Hirsch conjecture II","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/io/#File-I/O","page":"File I/O","title":"File I/O","text":"","category":"section"},{"location":"man/io/","page":"File I/O","title":"File I/O","text":"readineq","category":"page"},{"location":"man/io/#Spindles.readineq","page":"File I/O","title":"Spindles.readineq","text":"readineq(filename, T [, comment_char])\n\nFile format: labels b -A Return A, b, labels where A is a matrix of type Rational{T}.\n\nLines starting with a comment_char character (default is '#') and all characters on a line following  a comment_char are ignored.\n\nExamples\n\njulia> str = \"# unit square\\na 1 -1 0\\nb 1 0 -1\\nc 1 1 0\\nd 1 0 1\";\n\njulia> println(str)\n# unit square\na 1 -1 0\nb 1 0 -1\nc 1 1 0\nd 1 0 1\n\njulia> open(\"square.txt\", \"w\") do io\n           write(io, str)\n       end;\n\njulia> A, b, labels = readineq(\"square.txt\", Int);\n\njulia> A\n4×2 Matrix{Rational{Int64}}:\n  1   0\n  0   1\n -1   0\n  0  -1\n\njulia> b\n4-element Vector{Rational{Int64}}:\n 1\n 1\n 1\n 1\n\njulia> labels\n4-element Vector{String}:\n \"a\"\n \"b\"\n \"c\"\n \"d\"\n\njulia> rm(\"square.txt\")\n\n\n\n\n\n","category":"function"},{"location":"man/io/","page":"File I/O","title":"File I/O","text":"Spindles.writeineq","category":"page"},{"location":"man/io/#Spindles.writeineq","page":"File I/O","title":"Spindles.writeineq","text":"writeineq(outfilename, A::AbstractMatrix, b::AbstractVector [, labels, labels_plusminus, comments, comment_char])\n\nWrite the inequality description Ax le b to outfilename.\n\nThe file format is [labels b -A]. First column contains inequality labels.\n\nKeywords\n\nlabels: If not specified, use inequality indices.\nlabels_plusminus::Bool: Defaults to false\ncomments: Each element in comments will be printed on its own line, starting with comment_char  and a whitespace. Possible internal line breaks are ignored.\ncomment_char: default is '#'\n\n\n\n\n\n","category":"function"},{"location":"man/io/","page":"File I/O","title":"File I/O","text":"Spindles.readrational","category":"page"},{"location":"man/io/#Spindles.readrational","page":"File I/O","title":"Spindles.readrational","text":"readrational(filename, T)\n\nT type of numerator and denominator\n\n\n\n\n\n","category":"function"},{"location":"man/plots/#Plotting-faces","page":"Plots","title":"Plotting faces","text":"","category":"section"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"Since the initial purpose of Spindles.jl is the detection of 2-faces of special polytopes with certain  (combinatorial or geometric) properties, the package provides a function to visualize 2-faces.  Often drawings help understand those properties (which is also why these documentation pages aim to visualize as much as possible.","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"note: Implementation note\nThe implementation in Spindles.jl heavily relies on Plots.jl. Two-dimensional faces of polytopes may also be visualized using Polyhedra.jl.","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"The plotting function of Spindles.jl is called plot2face and is best described using an example. ","category":"page"},{"location":"man/plots/#Example","page":"Plots","title":"Example","text":"","category":"section"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"We will use the following simple polytope, a square in 2D given by","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"beginaligned\n-1 le x_1 le 1 \n-1 le x_2 le 1\nendaligned","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"using Spindles #hide\nsquare = Polytope([1 0; 0 1; -1 0; 0 -1], [1, 1, 1, 1])\nvertices(square)","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"Since square is two-dimensional already, the most basic form of calling plot2face  just takes as arguments the polytope and a list of inequality indices that define the face to be drawn. In our example, this list is empty to get the maximal face, the polytope itself:","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"plot2face(square, Int[])","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"By default, vertices are labeled by their index in vertices(square). The edge labels indicate which facet-defining inequalities for square define the edge. We may relabel vertices and edges using the keyword  arguments vertexlabels and ineqlabels as follows:","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"plot2face(square, Int[]; vertexlabels=[\"a\", \"b\", \"c\", \"d\"], ineqlabels=[\"^\", \"*\", \"+\", \"-\"])","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"If we are only interested in the combinatorics of square (which of course isn't all too interesting), we can tell plot2face to make a plot of the graph of square, where vertices are placed equidistantly on a cycle. In our example, this of course does not change too much:","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"plot2face(square, Int[]; usecoordinates=false)","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"Another option that has its origins in the theoretical analysis of 2-faces allows for marking up a pair of edges. To see the effect, let us drop the edge labels for the moment. This is achieved by setting ineqlabels to nothing.","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"plot2face(square, Int[]; ineqlabels=nothing, directed_edges=([1,3], [2,4]))","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"Now perturb the square slightly so that those two edges are no longer parallel.","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"perturbed_square = Polytope([1 -1//8; 0 1; -1 -1//8; 0 -1], [9//8, 1, 9//8, 1])\nvertices(perturbed_square)","category":"page"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"plot2face(perturbed_square, Int[]; ineqlabels=nothing, directed_edges=([1,3], [2,4]))","category":"page"},{"location":"man/plots/#Full-reference","page":"Plots","title":"Full reference","text":"","category":"section"},{"location":"man/plots/","page":"Plots","title":"Plots","text":"plot2face","category":"page"},{"location":"man/plots/#Spindles.plot2face","page":"Plots","title":"Spindles.plot2face","text":"plot2face(\n    p::Polytope, indices;\n    usecoordinates = true,\n    vertexlabels = ,\n    ineqlabels = ,\n    directed_edges = nothing,\n    # plot kw args\n    kw...\n)\n\nMake a plot of the 2-face of p that is defined by the inequalities in indices,  either as a 2D projection onto the plane (if the argument usecoordinates is set to true) or as a (combinatorial) plot of its graph otherwise.\n\nKeywords\n\nusecoordinates: If true (default), plot a 2D projection. Otherwise draw the graph.\nvertexlabels: A list of strings or nothing to suppress labels. Default: ... vertexlabels[i] for vertex i.\nineqlabels: A list of strings to be used as facet labels, or nothing to suppress labels. Default:\ndirected_edges: A tuple of edges ([s,t], [u,v]) that are drawn as directed edges. ...\n\nThe remaining keyword arguments kw... are passed to plot and can be any plot, subplot, or axis attributes. See also the Plots.jl documentation pages  for a list of available attributes. Some of them are used by plot2face with a  different default value than in Plots.jl. Notable keyword arguments among those are:\n\nsize: A tuple of Integers that determines the plot size. Defaults here to (300,300).\naspect_ratio: Defaults to :equal if usecoordinates is false, and :auto otherwise  (default in Plots.jl).\n\nThe default behaviour can be overwritten by explicitly passing new values as keyword arguments in kw... to plot2face. Anything in kw... takes precedence over the default behaviour in plot2face, except for (most) attributes related to annotations. They are hardcoded in plot2face.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"EditURL = \"../../../examples/firststeps.jl\"","category":"page"},{"location":"tutorials/firststeps/#First-steps","page":"First steps","title":"First steps","text":"","category":"section"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"(Image: )","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"This tutorial demonstrates the basic usage of Spindles.jl to create spindles and query basic properties.","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"note: Note\nThis tutorial is also available as a Jupyter notebook. Click on the badge above to view it in nbviewer.","category":"page"},{"location":"tutorials/firststeps/#Creating-a-spindle","page":"First steps","title":"Creating a spindle","text":"","category":"section"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"In this tutorial, we will be working with one of the simplest examples of a spindle: a cube. For example, the unit cube in 3D is given by all points (x_1x_2x_3) that satisfy","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"beginaligned\n-1 le x_1 le 1 \n-1 le x_2 le 1 \n-1 le x_3 le 1\nendaligned","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"In matrix notation, this is equivalent to the system Ax le b where","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"A = [1 0 0; -1 0 0; 0 1 0; 0 -1 0; 0 0 1; 0 0 -1]","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"and","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"b = [1, 1, 1, 1, 1, 1]","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"Spindles.jl provides a data type for representing and analyzing polytopes: Polytope. We may create an object of this type from our data A and b as follows:","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"using Spindles # hide\ncube = Polytope(A, b)","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"What sets a spindle apart from a general polytope is the existence of two vertices (the apices) whose incident facets partition the set of all facets. We may check cube for the existence of such a pair of vertices by running","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"apices(cube)","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"This returns the two indices of the apices as they appear in the list of all (eight) vertices of cube. To list the vertices explicitly, do","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"vertices(cube)","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"note: Note\nBy default, Spindles.jl uses exact rational arithmetic. Note that the components of each vertex returned by vertices are of type Rational with numerators and denominators of type BigInt to avoid integer overflows (see the Julia documentation pages on rational numbers and arbitrary-precision arithmetic).","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"So the first and last vertex in the list above can take the role of the apices of cube. However, these two are not unique. In fact, for a cube there are many possible pairs of apices: Take an arbitrary vertex and its antipodal one, i.e., the vertex obtained by flipping the sign of each component. To prescribe an apex, pass its index as an additional argument to the function apices, which then tries to find a matching second apex:","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"apx = apices(cube, 3)","category":"page"},{"location":"tutorials/firststeps/#Working-with-the-graph","page":"First steps","title":"Working with the graph","text":"","category":"section"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"We may even compute the distance between those two apices in the graph of cube:","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"dist(cube, apx...)","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"Behind the scenes, the call to dist first computes the graph of cube. The graph can also be accessed directly using graph, which returns a graph of a type defined by the Graphs.jl package. For instance, we may verify the well-known fact that cubes are simple by using the functions dim and Graphs.degree:","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"using Graphs: degree\nall(degree(graph(cube)) .== dim(cube))","category":"page"},{"location":"tutorials/firststeps/#Counting-and-enumerating-faces","page":"First steps","title":"Counting and enumerating faces","text":"","category":"section"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"Spindles.jl also provides functions to count and enumerate the faces of cube. The following call to facesofdim returns a list of all two-dimensional faces, each one given by the indices of its incident facets.","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"note: Note\nNote here that facet indices refer to the corresponding rows of the coefficient matrix A.","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"facesofdim(cube, 2)","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"Given that the two-dimensional faces of a cube are precisely its six facets, this should not be too surprising.","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"To count the faces of a given dimension without explicitly producing a list, use the function nfacesofdim. For example, we may compute the f-vector of cube as follows.","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"nfacesofdim.(cube, 0:(dim(cube)-1))","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"This tells us that cube has 8 vertices, 12 edges, and 6 facets.","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"Next, let's list all vertices that are incident to the first facet.","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"for v in incidentvertices(cube, [1])\n    println(collect(vertices(cube))[v])\nend","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"As expected, we obtain precisely the four vertices whose first component is equal to one.","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"note: Note\nvertices returns an iterator. To access a specific element, use collect as in the code above.","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"","category":"page"},{"location":"tutorials/firststeps/","page":"First steps","title":"First steps","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/polytopes/#Polytopes","page":"Polytopes","title":"Polytopes","text":"","category":"section"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"DocTestSetup = quote\n    import Polyhedra\n    using Spindles\nend","category":"page"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"The main type defined by Spindles.jl is the type Polytope that represents a polytope. Objects of this type are constructed either from a V-representation (a list of points whose convex hull is the polytope) or from an H-representation (a system of linear inequalities whose set of solutions is the polytope):","category":"page"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"Polytope","category":"page"},{"location":"man/polytopes/#Spindles.Polytope","page":"Polytopes","title":"Spindles.Polytope","text":"Polytope(V::AbstractVector{Vector})\n\nCreate a polytope from the convex hull of the collection of points V.\n\n\n\n\n\nPolytope(V::AbstractMatrix)\n\nCreate a polytope from the convex hull of the rows of V.\n\n\n\n\n\nPolytope(A::AbstractMatrix, b::AbstractVector)\n\nCreate a polytope from its H-representation Ax le b.  If the polyhedron defined by Ax le b is unbounded, throw an error.\n\n\n\n\n\n","category":"type"},{"location":"man/polytopes/#Examples","page":"Polytopes","title":"Examples","text":"","category":"section"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"julia> p = Polytope([[0, 0], [1, 0], [0, 1], [1, 1]])\nPolytope{Rational{BigInt}}","category":"page"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"creates the polytope with vertices (00)(10)(01), and (11) (the two-dimensional 0/1 cube). This is the same as","category":"page"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"julia> q = Polytope([0 0; 1 0; 0 1; 1 1])\nPolytope{Rational{BigInt}}\n\njulia> p == q\ntrue","category":"page"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"note: Note\nTwo Polytopes are considered equal by the == operator if and only if they have the same set of vertices.","category":"page"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"Equivalently, our 2D polytope may be created from the inequality description","category":"page"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"beginaligned\n0 le x_1 le 1 \n0 le x_2 le 1\nendaligned","category":"page"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"by running","category":"page"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"julia> r = Polytope([-1 0; 1 0; 0 -1; 0 1], [0, 1, 0, 1])\nPolytope{Rational{BigInt}}\n\njulia> p == r\ntrue","category":"page"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"Unlike for the first two constructors above, there is no guarantee that a polyhedron defined by  a general system Ax le b is bounded (and, hence, a polytope). Indeed,  if we drop any of the four inequalities above – say the last one –, this property is lost:","category":"page"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"julia> Polytope([-1 0; 1 0; 0 -1], [0, 1, 0])\nERROR: ArgumentError: got an unbounded polyhedron\n[...]","category":"page"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"note: Type parameter\nPolytope is a parametric type. Namely, the precise type of each of the three objects constructed above is Polytope{Rational{BigInt}}, where the parameter Rational{BigInt} is called the element type and is inferred from the type of the data passed to the constructor. For example, Rational{BigInt} indicates that Polytope uses exact rational arithmetic to store and manipulate the coefficients in a V- or H-representation. For integer data, this is the default choice. Suppose that we change some of the input data above to floating-point numbers, such asjulia> Polytope([-1.0 0.0; 1 0; 0 -1; 0 1], [0, 1, 0, 1])\nPolytope{Float64}Then we get a different element type, namely Float64. The type of arithmetic used to represent and manipulate the Polytope object can also be set using an optional constructor argument that is borrowed from Polyhedra.jl (and that may be passed to any of the Polytope constructors):julia> using Polyhedra: DefaultLibrary\n\njulia> Polytope([-1.0 0.0; 1 0; 0 -1; 0 1], [0, 1, 0, 1], DefaultLibrary{Rational{BigInt}}())\nPolytope{Rational{BigInt}}This argument now specifies a library for polyhedral computations (the \"backend\" of Polyhedra.jl) that is to be used for the internal representation of the Polytope object. In this case, we chose the default library implemented in Polyhedra.jl but forced rational data instead of Floats.See also the JuliaPolyhedra website for a list of all supported libraries. For example, to use CDDLib with exact rational arithmetic, doimport CDDLib\nPolytope(A, b, CDDLib.Library(:exact))","category":"page"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"Also note that lists of points or inequality descriptions passed to one of the Polytope constructors need not be minimal: They may include non-vertices; and redundant inequalities or implicit equations in a system of linear inequalities are allowed, too. However, these can be detected, see the section on Redundancy and implicit equations below.","category":"page"},{"location":"man/polytopes/#Vertices","page":"Polytopes","title":"Vertices","text":"","category":"section"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"Spindles.vertices","category":"page"},{"location":"man/polytopes/#Spindles.vertices","page":"Polytopes","title":"Spindles.vertices","text":"vertices(p::Polytope)\n\nReturns an iterator over the vertices of the polytope p.\n\n\n\n\n\n","category":"function"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"nvertices","category":"page"},{"location":"man/polytopes/#Spindles.nvertices","page":"Polytopes","title":"Spindles.nvertices","text":"nvertices(p::Polytope)\n\nCount the vertices of p.\n\n\n\n\n\n","category":"function"},{"location":"man/polytopes/#Incidence","page":"Polytopes","title":"Incidence","text":"","category":"section"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"incidentvertices","category":"page"},{"location":"man/polytopes/#Spindles.incidentvertices","page":"Polytopes","title":"Spindles.incidentvertices","text":"incidentvertices(p::Polytope, indices::AbstractVector{Int})\n\nList the indices of all vertices of the polytope p for which each inequality in indices is tight.\n\nIf indices is empty, this is the same as collect(1:nvertices(p)).\n\n\n\n\n\n","category":"function"},{"location":"man/polytopes/#Dimension","page":"Polytopes","title":"Dimension","text":"","category":"section"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"Spindles.dim","category":"page"},{"location":"man/polytopes/#Spindles.dim","page":"Polytopes","title":"Spindles.dim","text":"dim(p::Polytope)\n\nCompute the dimension of p.\n\nThis is done by computing the length of a maximal chain in the face lattice of p, i.e., a finite sequence of faces \n\nemptyset = F_-1 subsetneq F_0 subsetneq F_1 subsetneq dots subsetneq F_d\n\nfor which d is maximal among all such sequences. Then F_d must be p itself, and d is its dimension.\n\nSee also Polyhedra.dim.\n\nExamples\n\njulia> p = Polytope([0 0; 1 0; 0 1; 1 1])\nPolytope{Rational{BigInt}}\n\njulia> dim(p)\n2\n\n\n\n\n\ndim(p::Polytope, indices)\n\nCompute the dimension of the face of p that is defined by the inequalities in indices. If indices is empty, this is the same as dim(p).\n\n\n\n\n\ndim(p::Polytope, i::Int)\n\nSame as dim(p, [i]).\n\nExamples\n\njulia> p = Polytope([-1 0; 1 0; 0 -1; 0 1], [0, 1, 0, 1])\nPolytope{Rational{BigInt}}\n\njulia> dim(p, Int[])\n2\n\njulia> dim(p, 1)\n1\n\njulia> dim(p, [1, 3])\n0\n\njulia> dim(p, [1, 2])\n-1\n\n\n\n\n\n","category":"function"},{"location":"man/polytopes/#Redundancy-and-implicit-equations","page":"Polytopes","title":"Redundancy and implicit equations","text":"","category":"section"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"When constructing a Polytope from an inequality description, any inequality description is allowed.  In particular, it may contain redundant inequalities (whose deletion leaves the polytope unchanged) or implicit equations (inequalities that are satisfied at equality by all points in the polytope). So the inequalities in a given description may be partitioned into three sets:","category":"page"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"a minimal set of facet-defining inequalities (which may not be unique), \na (possibly empty) set of implicit equations contained in the inequality system, and \nall remaining inequalities (that may safely be deleted). ","category":"page"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"This partition can be computed using the functions facets and impliciteqs, which return the first two sets of the partition.","category":"page"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"facets","category":"page"},{"location":"man/polytopes/#Spindles.facets","page":"Polytopes","title":"Spindles.facets","text":"facets(p::Polytope)\n\nReturn a minimal subset of inequality indices that contains one inequality for each facet of p.\n\nIf multiple inequalities in the description of p define the same facet, the one with the smallest index is selected.\n\nSee also nfacets, impliciteqs.\n\nExamples\n\n\n\n\n\n","category":"function"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"nfacets","category":"page"},{"location":"man/polytopes/#Spindles.nfacets","page":"Polytopes","title":"Spindles.nfacets","text":"nfacets(p::Polytope)\n\nCount the facets of p. Shorthand for length(facets(p)).\n\nSee also nfacesofdim, facets.\n\n\n\n\n\n","category":"function"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"impliciteqs","category":"page"},{"location":"man/polytopes/#Spindles.impliciteqs","page":"Polytopes","title":"Spindles.impliciteqs","text":"impliciteqs(p::Polytope)\n\nReturn the indices of all inequalities that are implicit equations, i.e., that are satisfied at equality for each point in p.\n\nSee also facets.\n\n\n\n\n\n","category":"function"},{"location":"man/polytopes/#Spindles","page":"Polytopes","title":"Spindles","text":"","category":"section"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"apices","category":"page"},{"location":"man/polytopes/#Spindles.apices","page":"Polytopes","title":"Spindles.apices","text":"apices(p::Polytope [, apex])\n\nCheck whether p is a spindle, i.e., if there is a pair of vertices (the apices) for which each facet of p is incident to exactly one of them. If p has a pair of apices, return their indices; otherwise return nothing.\n\nThe optional argument apex specifies the index of a vertex that is to be taken as one of the apices.\n\nExamples\n\njulia> square = Polytope([1 0; 0 1; -1 0; 0 -1], [1, 1, 1, 1]);\n\njulia> vertices(square)\n4-element iterator of Vector{Rational{BigInt}}:\n Rational{BigInt}[-1, -1]\n Rational{BigInt}[1, -1]\n Rational{BigInt}[-1, 1]\n Rational{BigInt}[1, 1]\n\njulia> apices(square)\n2-element Vector{Int64}:\n 1\n 4\n\njulia> apices(square, 2)\n2-element Vector{Int64}:\n 2\n 3\n\n\n\n\n\n","category":"function"},{"location":"man/polytopes/","page":"Polytopes","title":"Polytopes","text":"DocTestSetup = nothing","category":"page"},{"location":"man/faces/#Faces","page":"Faces","title":"Faces","text":"","category":"section"},{"location":"man/faces/","page":"Faces","title":"Faces","text":"DocTestSetup = quote\n    push!(LOAD_PATH, \"../../src\")\n    using Spindles\nend","category":"page"},{"location":"man/faces/#Enumeration","page":"Faces","title":"Enumeration","text":"","category":"section"},{"location":"man/faces/","page":"Faces","title":"Faces","text":"Spindles.jl implements an algorithm for enumerating all faces of a given dimension. The algorithm  is optimized for near-simple polytopes, i.e., polytopes with few degenerate vertices. It is inspired by an algorithm for computing the graph of a polytope described here (see also the paper).","category":"page"},{"location":"man/faces/","page":"Faces","title":"Faces","text":"facesofdim","category":"page"},{"location":"man/faces/#Spindles.facesofdim","page":"Faces","title":"Spindles.facesofdim","text":"facesofdim(p::Polytope, k::Int)\n\nEnumerate all faces of dimension k of the polytope p. Each face is given by a list of the indices of its incident halfspaces.\n\nNote here that the empty face emptyset (which is the unique face of dimension -1 by convention) is given by the list of all halfspace indices, as the intersection of all facets of a polytope is empty.\n\nwarning: Difference from Polyhedra.jl\nThe index of a halfspace is the index of the corresponding inequality in the linear description of p, where (explicitly given) equality constraints (defining hyperplanes) are ignored. This is different from  the way that indices are treated in Polyhedra.jl, where hyperplanes and halfspaces share the same set of indices.\n\nnote: Note\nThe algorithm proceeds recursively and computes faces bottom-up, starting from the vertices. The results are cached internally in the Polytope object p. Therefore,  subsequent calls to facesofdim(p, l) for any l le k do not cost anything.\n\nSee also nfacesofdim, dim.\n\n\n\n\n\n","category":"function"},{"location":"man/faces/","page":"Faces","title":"Faces","text":"nfacesofdim","category":"page"},{"location":"man/faces/#Spindles.nfacesofdim","page":"Faces","title":"Spindles.nfacesofdim","text":"nfacesofdim(p::Polytope, k::Int)\n\nCount the k-dimensional faces of the polytope p.  Shorthand for length(facesofdim(p, k)).\n\nSee also nfacets, facesofdim, dim.\n\nExamples\n\njulia> V = [(i >> j) & 1 for i=0:7, j=0:2]\n8×3 Matrix{Int64}:\n 0  0  0\n 1  0  0\n 0  1  0\n 1  1  0\n 0  0  1\n 1  0  1\n 0  1  1\n 1  1  1\n\njulia> cube = Polytope(V);\n\njulia> nfacesofdim.(cube, -1:3)\n5-element Vector{Int64}:\n  1\n  8\n 12\n  6\n  1\n\n\n\n\n\n","category":"function"},{"location":"man/faces/","page":"Faces","title":"Faces","text":"For example, calling facesofdim(p, 1) lists the incident halfspaces of each edge of the polytope p. These edges, given as pairs of adjacent vertices, define the graph (or 1-skeleton) of p. The graph can also be retrieved directly:","category":"page"},{"location":"man/faces/","page":"Faces","title":"Faces","text":"graph","category":"page"},{"location":"man/faces/#Spindles.graph","page":"Faces","title":"Spindles.graph","text":"graph(p::Polytope)\n\nReturn the graph of the polytope p, which is a simple undirected graph of type  Graphs.SimpleGraphs.SimpleGraph.\n\n\n\n\n\n","category":"function"},{"location":"man/faces/#Length-of-paths","page":"Faces","title":"Length of paths","text":"","category":"section"},{"location":"man/faces/","page":"Faces","title":"Faces","text":"dist","category":"page"},{"location":"man/faces/#Spindles.dist","page":"Faces","title":"Spindles.dist","text":"dist(p::Polytope, u::Int, v::Int)\n\nCompute the distance between vertices u and v in the graph of p.\n\nExamples\n\njulia> p = Polytope([1 0; 0 1; -1 0; 0 -1], [1, 1, 1, 1]);\n\njulia> vertices(p)\n4-element iterator of Vector{Rational{BigInt}}:\n Rational{BigInt}[-1, -1]\n Rational{BigInt}[1, -1]\n Rational{BigInt}[-1, 1]\n Rational{BigInt}[1, 1]\n\njulia> dist(p, 1, 4)\n2\n\n\n\n\n\n","category":"function"},{"location":"man/faces/#Good-faces","page":"Faces","title":"Good faces","text":"","category":"section"},{"location":"man/faces/","page":"Faces","title":"Faces","text":"Spindles.FaceState","category":"page"},{"location":"man/faces/#Spindles.FaceState","page":"Faces","title":"Spindles.FaceState","text":"FaceState\n\nFields\n\ngood::Bool\nfacets: all incident halfspaces\nedges\nvsets\n\n\n\n\n\n","category":"type"},{"location":"man/faces/","page":"Faces","title":"Faces","text":"isgood2face","category":"page"},{"location":"man/faces/#Spindles.isgood2face","page":"Faces","title":"Spindles.isgood2face","text":"isgood2face(p::Polytope, indices, src, dst)\n\nTest the face defined by indices for being a good 2-face of the polytope p with respect to the two vertices src and dst. Return a FaceState.\n\nSee this tutorial for an informal explanation of what it means for a 2-face to be good.\n\n\n\n\n\n","category":"function"},{"location":"#Spindles.jl","page":"Home","title":"Spindles.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The goal of Spindles.jl is to provide a lightweight interface for representing and analyzing polytopes. The initial purpose of the package is to facilitate research in polyhedral theory on so-called spindles.","category":"page"},{"location":"#What-is-a-spindle?","page":"Home","title":"What is a spindle?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A spindle is a polytope with two special vertices such that each facet contains exactly one of them. These two special vertices are called the apices of the spindle. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"A simple example is a cube: For each vertex u, there is a unique vertex v that does not share a facet with u (namely, the vertex that is \"antipodal\" to u). Any such pair u and v is a valid pair of apices for the cube.","category":"page"},{"location":"#Why-are-spindles-important?","page":"Home","title":"Why are spindles important?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Spindles play an important role in the construction of counterexamples to the Hirsch conjecture. In fact, a computational analysis of these counterexamples was the main driver of the development of Spindles.jl. More details can be found in this tutorial.","category":"page"},{"location":"#Who-is-this-package-for?","page":"Home","title":"Who is this package for?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Spindles.jl is built as a lightweight toolkit for basic computational tasks in polyhedral research.  Even though the package was born out of a research project focused on a special class of polytopes, namely spindles, its implementation is not specific to spindles at all. In fact, it allows for representing and analyzing any polytope. For example, Spindles.jl implements lightweight (and mostly combinatorial) algorithms to enumerate and count faces, compute the dimension, or detect redundancy in a given linear description of a polytope.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Of course, there are many great (and free) software packages and libraries for manipulating polyhedra that offer much more than Spindles.jl does. A (non-exhaustive) list of examples from the Julia ecosystem is:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Polyhedra.jl: Implements the double description method for converting representations of polyhedra into each other. Also provides an interface to many other libraries for polyhedral computations, see the JuliaPolyhedra website.\nPolymake.jl: Julia wrapper for polymake and part of the OSCAR computer algebra system.\nCDDLib.jl: Julia wrapper for cdd.\nLRSLib.jl: Julia wrapper for lrs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The latter two are examples of libraries that can also be used with Polyhedra.jl, as a couple of others listed on the JuliaPolyhedra website.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nIt should be noted that Spindles.jl currently relies on Polyhedra.jl to convert a polytope given by a system of linear inequalities into a list of its vertices, and vice versa.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the full API reference for more technical details on the package design and its functionalities.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Using Spindles.jl requires a working installation of Julia. Download files and detailed instructions are available on the Julia website.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To install the latest stable version of Spindles.jl, clone the parent GitHub repository by running ","category":"page"},{"location":"","page":"Home","title":"Home","text":"git clone --branch v0.2.1 https://github.com/ma-b/hirsch-walks.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"in the command line. In the Spindles subdirectory of your local clone, open the Julia REPL and enter Pkg mode by pressing ]. Then run","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> dev .","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nSee also the Pkg documentation on the dev (or develop) command.","category":"page"},{"location":"","page":"Home","title":"Home","text":"You are now ready to use Spindles.jl by typing","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Spindles","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For the basic usage of Spindles.jl, please read the tutorial on first steps.  The full documentation can be found here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To learn more about how Spindles.jl can help analyze counterexamples to the Hirsch conjecture, please check out this tutorial.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nIf you would like to run some of the examples presented in the tutorials yourself, you can view or download them as Jupyter notebooks. The links can be found on the respective tutorial pages.Note that the Julia kernel for Jupyter notebooks is required to run the example notebooks in your own Julia environment. It can be installed in Pkg mode by runningpkg> add IJulia\npkg> build IJulia","category":"page"},{"location":"man/api/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"man/api/","page":"Index","title":"Index","text":"Spindles","category":"page"},{"location":"man/api/#Spindles","page":"Index","title":"Spindles","text":"Main module. The public API is listed below.\n\n\n\n\n\n","category":"module"},{"location":"man/api/","page":"Index","title":"Index","text":"","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"EditURL = \"../../../examples/hirsch-i.jl\"","category":"page"},{"location":"tutorials/hirsch-i/#Spindles-and-the-Hirsch-conjecture-I","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"","category":"section"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"(Image: )","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"In this tutorial, we will explore a particular spindle that is known from theory to have an interesting property: Its apices are far away from each other in the graph of the spindle. This property made it possible to disprove a long-standing conjecture in polyhedral theory, the so-called Hirsch conjecture. Even though the focus of this tutorial is on a thorough analysis of the special spindle, we will showcase some more advanced functionalities and customization options of Spindles.jl along the way. For the basic usage, please read this tutorial first.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"note: Note\nThis tutorial is also available as a Jupyter notebook. Click on the badge above to view it in nbviewer.","category":"page"},{"location":"tutorials/hirsch-i/#The-Hirsch-conjecture","page":"Spindles and the Hirsch conjecture I","title":"The Hirsch conjecture","text":"","category":"section"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"The Hirsch conjecture for polytopes stated that any two vertices of a d-dimensional polytope with f facets can be connected by a path of at most f-d edges. It was disproved in 2010 when Francisco Santos found a construction that produces counterexamples from spindles with a special property: the length of a shortest path between the apices (called the length of the spindle) must be strictly greater than the dimension.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Santos' original counterexample from 2010 is based on a 5-dimensional spindle with 48 facets, for which the shortest path between the apices is of length 6. A minimal inequality description of this spindle (see Table 1 in Santos' paper) can be found in the file s-48-5.txt located in the examples folder beneath the package root directory Spindles.","category":"page"},{"location":"tutorials/hirsch-i/#Reading-a-spindle-from-a-file","page":"Spindles and the Hirsch conjecture I","title":"Reading a spindle from a file","text":"","category":"section"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"We may read the description from the file as follows.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"using Spindles\nA, b, labels = readineq(\"../../../examples/s-48-5.txt\", Int);\nnothing #hide","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"[A b]","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"The function readineq does not only return the data in the inequality description Ax le b from the source but also the attached labels, one for each inequality.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"labels","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"note: Note\nEven though we use the same set of labels as Santos in his paper, the assignment to the rows of A is different.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"The resulting spindle s has","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"s = Polytope(A, b)\nnvertices(s)","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"vertices and its apices are","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"apx = apices(s)\ncollect(vertices(s))[apx]","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"The distance between them in the graph of s is indeed 6:","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"dist(s, apx...)","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Note that both apices are highly degenerate:","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"using Graphs: degree\ndegree(graph(s), apx)","category":"page"},{"location":"tutorials/hirsch-i/#Inspecting-faces","page":"Spindles and the Hirsch conjecture I","title":"Inspecting faces","text":"","category":"section"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"The original motivation for developing Spindles.jl was the search for special two-dimensional faces (or 2-faces for short) of the spindle s and similar spindles. To explain what we mean by \"special\", let us consider the following three facets (note that all inequalities in the description given in s-48-5.txt are indeed facet-defining):","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"face = [29, 37, 41]\nlabels[face]","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"They indeed define a 2-face of s:","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"face in facesofdim(s, 2)","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"To inspect face, we may use the function plot2face provided by Spindles.jl to make a plot.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"plot2face(s, face; ineqlabels=labels)","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Each vertex is labeled by its index. Edges and the face itself get their labels from the incident facets, since we passed the labels extracted above to the keyword argument ineqlabels. Note here that the three facets that contain face are omitted from the edge labels.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"We may customize the above plot even further. For example, let's add more information to the vertex labels. To print the distances of each vertex to the two apices of s on a second line beneath the vertex index, we first generate all labels in the desired format. Here, we use the format \"dist1 | dist2\" for the second line of the label, where dist1 and dist2 are placeholders for the distances to apx[1] and apx[2], respectively.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"dist_labels = map(1:nvertices(s)) do v\n    \"$v\\n\" * join(dist.(s, apx, v), \" | \")\nend","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"note: Julia syntax\ndist.(s, apx, v)is a shorthand for[dist(s, a, v) for a in apx]","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Our custom vertex labels can now be passed to plot2face as follows:","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"plot2face(s, face; ineqlabels=labels, vertexlabels=dist_labels, usecoordinates=false)","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Note here that the (optional) additional argument usecoordinates=false changed the plot mode to a (combinatorial) drawing of the graph of the face 15⁺ 19⁺ 21⁺ rather than a planar projection of its true coordinates as above.","category":"page"},{"location":"tutorials/hirsch-i/#A-good-2-face","page":"Spindles and the Hirsch conjecture I","title":"A good 2-face","text":"","category":"section"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Next, let's take a closer look at our custom labels in the plot that we just generated. For each vertex of the face, the sum of both distances on the second line of its label must be at least 6, since we know that there is no shorter path between the apices. In fact, there are (at least) two such shortest paths that traverse parts of the face: One of the apices of s actually is a vertex of the face, namely the first apex","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"apx","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"at index 1. Start from there and take 3 steps to either 56 or 80. Both vertices are at distance 3 from the second apex, as their labels tell us. The only two vertices that are not visited on either of those two paths are 155 and 156, and they are also at distance 3 from the second apex.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"So among the vertices of the face 15⁺ 19⁺ 21⁺, there are two special subsets: One subset of vertices, let us call it V_1, is \"close\" to the first apex (namely, take V_1 to be the apex 1 itself). The other subset V_2 (the subset consisting of 56, 155, 156, and 80) is disjoint from the first one, and each vertex in V_2 is \"close\" to the second apex . Here, \"close\" means that if we pick two arbitrary vertices, one from each subset, then the sum of their distances to the respectively closest apex is at most some given number k. In our case, any k ge 3 would work for this definition of being \"close\", since the distance of V_1 to apx[1] is 0 and that of any vertex in V_2 to apx[2] is 3.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Let's visualize the two sets V_1 and V_2. Again, we tweak the arguments passed to plot2face and label the vertices of the face by which set they belong to. For example, this can be achieved by","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"set_labels = map(1:nvertices(s)) do v\n    if v == 1\n        return \"$v ∈ V₁\"\n    elseif v in [56, 155, 156, 80]\n        return \"$v ∈ V₂\"\n    else\n        return \"$v\"  # default label for vertices in neither of the two sets\n    end\nend\nplot2face(s, face; ineqlabels=nothing, vertexlabels=set_labels, usecoordinates=false, title=\"V₁ and V₂\")","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Note that there are exactly two edges of the face 15⁺ 19⁺ 21⁺ whose endpoints do not belong to neither V_1 nor V_2 (and, hence, are only labeled by their index in the plot above). These edges are those between 25 and 57, and between 33 and 81. Let's mark them up in the plot using the keyword argument directed_edges:","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"plot2face(s, face;\n    ineqlabels=nothing, vertexlabels=set_labels,\n\tdirected_edges=([25,57], [33,81]),\n    usecoordinates=false, title=\"V₁ and V₂\"\n)","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Not only are the two edges marked up in the plot, they are also drawn as directed edges now. To see why (and how this direction is determined by plot2face), recall that each of them is contained in a shortest path between the apices of s that walks along parts of the face 15⁺ 19⁺ 21⁺. For example, coming from the second apex (the one not contained in the face) and heading towards the first apex 1, the two red edges are traversed in exactly the direction indicated above. If we look at the \"true\" geometry of 15⁺ 19⁺ 21⁺, though, we could also start from any vertex in V_2 and follow one of the two red arrows (through the interior of the face!) as far as possible without leaving the face.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"plot2face(s, face;\n    ineqlabels=nothing, vertexlabels=set_labels,\n\tdirected_edges=([25,57], [33,81]),\n    usecoordinates=true, title=\"V₁ and V₂\"\n)","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"The geometry of the 2-face tells us that the point on the boundary that we hit must be on one of the two edges incident to the apex 1. From that point, we walk along the edge and reach 1 within (at most) two steps on the face, rather than three steps along its boundary. So, in a relaxed regime where paths may pass through the interior of a face, one might consider taking three edges steps from the second apex to some vertex in V_2, then apply the two-step \"shortcut\" through the interior of the face 15⁺ 19⁺ 21⁺, and end up at the first apex 1. This yields (at most) 5 steps in total. Recall that in the traditional regime where paths through the interior are forbidden, one cannot do better than 6 steps.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"note: Note\nIt is important to note here that, unlike paths along edges, this shortcut has a direction associated to it. The direction is determined by the geometry of the 2-face 15⁺ 19⁺ 21⁺ and is indicated by the direction of the two red edges. When making a plot with plot2face as above, they are always drawn in such a way that the arrows \"point away\" from each other.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Shortcuts like this are precisely what makes faces such as 15⁺ 19⁺ 21⁺ interesting for analyzing s in the setting of the so-called circuit diameter conjecture, a relaxation of the Hirsch conjecture that allows for paths through the interior of a polytope.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Let us call a 2-face of a spindle a good 2-face if it allows for such a shortcut between the apices as above (regardless of its direction). Spindles.jl provides a function isgood2face that tests a face for being good.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"isgood2face(s, face, apx...)","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"The result is wrapped in a bespoke data type called FaceState. The field good indicates whether or not the tested face is good, and the two vertex sets V_1 and V_2 that certify the property of being good are stored in the field vsets (see also the documentation on the FaceState type):","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"fstate = isgood2face(s, face, apx...)\nfstate.good, fstate.vsets","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Feel free to compare the output with the sets V_1 and V_2 that we identified above.","category":"page"},{"location":"tutorials/hirsch-i/#Finding-all-good-2-faces","page":"Spindles and the Hirsch conjecture I","title":"Finding all good 2-faces","text":"","category":"section"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"Using the function facesofdim and isgood2face, all good 2-faces of s are easily enumerated.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"for f in sort(facesofdim(s, 2))\n    if isgood2face(s, f, apx...).good\n        println(join(labels[f], \" \"))\n    end\nend","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"In particular, for each good 2-face, there must exist paths from both apices to some vertex on the face of total length at most 3. Interestingly, all 2-faces of s that satisfy this weaker condition are good:","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"for f in sort(facesofdim(s, 2))\n    min_total_length = sum(\n        minimum(\n            dist(s, a, v) for v in incidentvertices(s, f)\n        ) for a in apx\n    )\n    if min_total_length <= 3\n        println(join(labels[f], \" \"), \"\\t\", isgood2face(s, f, apx...).good)\n    end\nend","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"If you would like to explore one of the actual counterexamples to the Hirsch conjecture that was built from a spindle like s, please read on here.","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"","category":"page"},{"location":"tutorials/hirsch-i/","page":"Spindles and the Hirsch conjecture I","title":"Spindles and the Hirsch conjecture I","text":"This page was generated using Literate.jl.","category":"page"}]
}
